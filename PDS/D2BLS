D2BLS    TITLE '- D2BLS - Build IPCS Format Model from DSECT listing'
*---------------------------------------------------------------------*
*                                                                     *
*        DSECT To BLS... statements (IPCS Format Model)               *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*        Note: OA45131 adds > 8 character PREFIX= value and           *
*                      also adds "LAST8" keyword.                     *
*                      With this in mind, this tool will always       *
*                      use "LAST8" if the remaining label length      *
*                      is longer than 8 bytes.                        *
*                      This APAR also adds "LABEL=" to specify a      *
*                      totally different label for the field.         *
*                      Code for this will come later.                 *
*                                                                     *
*                      Nicholas R. (Nick) Jones,                      *
*                      z/OS MVS BCP Development - IPCS, Service Aids  *
*                      Added the above and I appreciate his help      *
*                      in understanding these concepts.               *
*                      I also thank him for listening to my thoughts  *
*                      and making them a reality which others can     *
*                      use to make better format models.              *
*                                                                     *
*                                                                     *
*        To Create a control block mapping for IPCS:                  *
*                                                                     *
*        EXEC PGM=D2BLS,PARM= ...                                     *
*             ACROLBL=      - Control Block Acronym Label             *
*             ACRONYM=      - Control Block Acronym                   *
*             BASELBL=      - Control Block Base Label                *
*             CBLEN=        - Control Block Length                    *
*             CSECT         - Define Mapping As A CSECT               *
*                           ... Implies "END"                         *
*             DECODE=       - Decode EQU Labels                       *
*             END           - Finish Mapping With an END              *
*             NOEND         - Do Not Finish with "END"                *
*             HEADER=       - Mapping Header Label                    *
*             LABEL=        - Unique Sub-Label Prefix                 *
*             LAST8         - NAME= last 8 bytes of label             *
*             MAINTLV=      - Mapping Maintenance Level               *
*             NAME=         - Mapping Name                            *
*             OFFSETS=      - OFFSETS=PRINT | NOPRINT                 *
*             PREFIX=       - Label Prefix String                     *
*             PRINT=        - PRINT=GEN | NOGEN                       *
*             SHEADER=      - Define Model Starting Text              *
*             SFOOTER=      - Define Model Trailing Text              *
*             START=        - Define Starting DSECT Label             *
*             EXIT=         - Symbol Exit Routine.                    *
*                             (See EXITPARM for Parameter List)       *
*                                                                     *
*        D2BUSERX is automatically called if it is LINKED with        *
*        this module.  See EXITPARM for the parameters that are       *
*        passed to the exit.                                          *
*        A NON-Zero return code indicates that the DSECTMAP entry     *
*        is to be ignored.                                            *
*        Any field (execpt DSECTNXT) can be altered to influence the  *
*        statement that will be produced.  DSECTFL2 is especially     *
*        useful for adding options.                                   *
*        EXITTRA@/EXITTRAR can be used to produce SYSTRACE output.    *
*        EXITPUN@/EXITPUNR can be used to produce SYSPUNCH output.    *
*        I've found EXITPUN@/EXITPUNR useful for adding new records   *
*        to the PUNCH output file.                                    *
*                                                                     *
*        As the combination of these PARMS could exceed the current   *
*        maximum length of a PARM= field, they may also be specified  *
*        in a SYSIN data set.  The syntax of SYSIN is similar to      *
*        the PARM field whereas it is a continuous string of keywords *
*        separated by commas.  SHEADER & SFOOTER can be enclosed in   *
*        quotes if they contain blanks.                               *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*        Below are the current BLSQMDEF/BLSQMFLD macro keywords.      *
*        This program does not use them all.                          *
*        As this tool grows it may use more options in the future.    *
*                                                                     *
*                                                                     *
*        BLSQMDEF                                                     *
*              BASELBL=                                               *
*              CBLEN=                                                 *
*              MAINTLV=      (Julian Date)                            *
*              ACRONYM=                                               *
*              ACROLEN=                                               *
*              ACROLBL=                                               *
*              ACROFF=                                                *
*              PREFIX=       (Always specify PREFIX=0)                *
*              OFFSETS=PRINT | NOPRINT                                *
*              STRTCOL=      (Not Used)                               *
*              LBLSPC=                                                *
*              HEADER=                                                *
*              VIEWMATCH=                                             *
*                                                                     *
*        BLSQMFLD                                                     *
*              NAME=                                                  *
*                 SHDR=                                               *
*                 OFF=                                                *
*                 LEN=          (If LEN=0 ignore this field)          *
*                 VIEW=                                               *
*                 ARRAY=                                              *
*                 DTYPE=HEX | EBCDIC | ANY | QANY | ASCII             *
*                 DECODE                                              *
*                 INVERT                                              *
*                 ATTACH                                              *
*                 IMBED                                               *
*                 STACK                                               *
*                 CALLCBF                                             *
*                 NEWLINE                                             *
*                 NOLABEL                                             *
*                 CALLRTN                                             *
*                 LABEL=                                              *
*                 LAST8                                               *
*                 PREFIX=                                             *
*                 NOSPLIT                                             *
*                 NUMDEC                                              *
*                 NOCOLNM                                             *
*                 NOROWNM                                             *
*                 STRTCOL=                                            *
*                 COLNUM=                                             *
*                 COLSEP=                                             *
*                 ITEMSEP=                                            *
*                 ORDER=                                              *
*                 HEXONLY                                             *
*                 MODELNAME                                           *
*                 MSGID                                               *
*                 SRCNDX=                                             *
*                                                                     *
*        BLSQMDEF END                                                 *
*                                                                     *
*---------------------------------------------------------------------*
*                                                                     *
*        History:                                                     *
*              #DD14109 - Version 1 Release 1 - Creation Date         *
*              #DD15243 - Add Installation User Exit Calls            *
*                                                                     *
*---------------------------------------------------------------------*

         DCLSW $ACROLBL,     PARM= ACROLBL=                            *
               $ACRONYM,           ACRONYM=                            *
               $BASELBL,           BASELBL=                            *
               $CBLEN,             CBLEN=                              *
               $CSECT,             CSECT                               *
               $DECODE,            DECODE=                             *
               $END,               END                                 *
               $HEADER,            HEADER=                             *
               $LAST8,             LAST8                               *
               $LABEL,             LABEL=                              *
               $MAINTLV,           MAINTLV=                            *
               $NAME,              NAME=                               *
               $OFFSETS,           OFFSETS=                            *
               $PREFIX,            PREFIX=                             *
               $PRINT,             PRINT=                              *
               $SHEADER,           SHEADER=                            *
               $SFOOTER,           SFOOTER=                            *
               $START,             START=                              *
               $NO_RSV,            NO_RSV                              *
               $PTF,               PTF=                                *
               $TRACE,       SYSTRACE DD statement exists              *
               $PARM,        PARM= Simulated from SYSIN                *
               MF=D

D2BLS    #START ,                  Start Procedure                     *
               AMODE=31,           Execute In 31-Bit AMode             *
               RMODE=24,           Execute In 24-Bit RMode (GET/PUT)   *
               BASE=RELATIVE,      Use Relative Addressing             *
               CONSTANT=R12,       Constants Base Register(s)          *
               WKDSECT=D2BWORK,    Define WorkArea Name                *
               LOC=BELOW,          Indicate 24-Bit WorkArea            *
               STORAGE=YES,        Obtain WorkArea With STORAGE Macro  *
               #REGS=BOTH,         Define Standard & AR Registers      *
               LEVEL=V01R002       Maintenance Level
         USING PSA,0

*---------------------------------------------------------------------*
*        Read SYSIN If PARM= was not specified                        *
*---------------------------------------------------------------------*
         ST    R1,WRKPARM@         A(Input Paramters)
         #ICALL CheckParm          Read SYSIN If PARM= Not Specified
         #SETRC (R15)
         LTR   R15,R15             Check If OPEN Was Successful
         JNZ   BLSQEXIT            B. If Not

*---------------------------------------------------------------------*
*        Parse Input Parameter List                                   *
*---------------------------------------------------------------------*
         #ICALL ParseParm          Parse Input Parameter List
         #SETRC (R15)
         LTR   R15,R15             Check If Parse Was Successful
         JNZ   BLSQEXIT            B. If Not

*---------------------------------------------------------------------*
*        Open the Input & Output Files & Inhale Assembler Output File *
*---------------------------------------------------------------------*
         #ICALL OpenFiles          Open Input & OUTPUT Files
         #SETRC (R15)
         LTR   R15,R15             Check If OPEN Was Successful
         JNZ   BLSQEXIT            B. If Not

         #ICALL LoadASM            Read Entire Assembler Output

*---------------------------------------------------------------------*
*        Find & Save All the DSECT Information                        *
*---------------------------------------------------------------------*
         #ICALL FindDsect          Find The Specified DSECT Label
         #SETRC (R15)

         #ICALL DumpDsect          Dump The DSECT Sequentially

*---------------------------------------------------------------------*
*        Generate BLSQMDEF/BLSQMFLD Statements                        *
*---------------------------------------------------------------------*
         #ICALL BuildBLS           Build & Print The IPCS Statements
         #SETRC (R15)

*---------------------------------------------------------------------*
*        TERMINATE                                                    *
*---------------------------------------------------------------------*
BLSQEXIT DS    0H
         #ICALL CloseFiles         Close Any Currently Open Files
         #STOP ,                   Return To Caller

*---------------------------------------------------------------------*
*                                                                     *
*        Build Simulated PARM= From SYSIN If No Real PARM=            *
*                                                                     *
*---------------------------------------------------------------------*
CheckParm #IPROC ,
         ICM   R1,15,WRKPARM@      A(Input Parameters)
         JZ    Chec0100            B. If Called With No PARM
         ICM   R1,15,0(R1)         A(Parameter List)
         LA    R1,0(,R1)           Clear High Order Bit
         LTR   R1,R1
         JZ    Chec0100            B. If No PARM= Specified
         SLR   R2,R2
         ICM   R2,3,0(R1)          Check Length Of PARM=
         JNZ   ChecRC00            B. If Specified

Chec0100 DS    0H
         STORAGE OBTAIN,LENGTH=4096,LOC=ANY,SP=1,CHECKZERO=YES
         ST    R1,WRKPARMS         Save Simulated PARM=
         XC    0(2,R1),0(R1)       Zero PARM= Length
         #BLANK 2(,R1),LEN=4094    Blank The PARM= Buffer
         SET   $PARM               Indicate PARM= Is Simulated
         LA    R0,WRKPARMS
         ST    R0,WRKPARM@         Simulate PARM=

         OPEN  (SYSIN,(INPUT))     Open Input
         TM    DCBOFLGS-IHADCB+SYSIN,DCBOFOPN
         JNO   ChecRC08            B. If "SYSIN" Did Not Open

         L     R5,WRKPARMS         A(PARM= Buffer)
         AHI   R5,2                A(Start Of PARM= Text Area)
         ST    R5,WRKPARMT         Save PARM= Text Starting Address

*        Read SYSIN And String Together Simulating PARM=
Chec0200 DS    0H
         GET   SYSIN               Read A Record From SYSIN
         CLI   0(R1),C'*'          Check For Comment Statement
         JE    Chec0200            B. If Yes (Ignore)
         CLC   0(72,R1),BLANKS     Check For Blank Line
         JE    Chec0200            B. If Yes
         MVC   0(72,R5),0(R1)      Save Input Record

         AHI   R5,71               A(End Of New Record)
Chec0300 DS    0H
         CL    R5,WRKPARMT         Back Up To The Beginning?
         JE    Chec0200            B. If Yes (Keep Reading)
         CLI   0(R5),C' '          Check For Last Non-Blank
         JNE   Chec0400            B. If End Was Found
         BRCT  R5,Chec0300         Back Up And Keep Looking

Chec0400 DS    0H
         AHI   R5,1                Point Past Input Data
         J     Chec0200            Keep Reading Till End-Of-File

Chec0500 DS    0H
         L     R1,WRKPARMS         A(PARM= Buffer)
         LR    R2,R1
         AHI   R2,2                A(Start Of PARM= Text Area)
         SR    R5,R2               Calculate Length
         STH   R5,0(,R1)           Save PARM= Text Length

ChecRC00 DS    0H
         LHI   R15,0               Set Return Code
         J     CheckXit

ChecRC8E DS    0H
         MVC   WrkTemp(ErrMsg07L),ErrMsg07
         WTO   TEXT=WrkTemp

ChecRC08 DS    0H
         LHI   R15,8               Set Return Code

CheckXit #IPEND ,

*---------------------------------------------------------------------*
*                                                                     *
*        Build And Output BLSQMDEF/BLSQMFLD Statements                *
*                                                                     *
*---------------------------------------------------------------------*
*  Syntax:
*
*        PUSH PRINT
*        PRINT NOGEN
*_______ DS    0H
* or
*_______ CSECT ,
*        BLSQMDEF BASELBL=.........1.........2.........3.........4.....
*              ....5.........6....,
*              CBLEN=X'_____',PREFIX=0,
*              HEADER=________,
*              ACROFF=______,ACROLEN=_____,OFFSETS=NOPRINT,
*              ACROLBL=.........1.........2.........3.........4........
*              .5.........6....,ACRONYM=________,
*              MAINTLV=________
*        BLSQMFLD NAME=.........1.........2.........3.........4........
*              .5.........6....,NEWLINE,LABEL=________,
*              DTYPE=________,VIEW=________,
*              OFF=X'______',LEN=_____
*        BLSQMFLD NAME=________,OFF=X'______',LEN=_,VIEW=X'0280',DECODE
*        BLSQMDEF END
*_______ BLSQSHDR '.........1.........2.........3.........4.........5..
*              .......6.........7'
*        POP  PRINT
*        END  ,
*
*---------------------------------------------------------------------*
BuildBLS #IPROC ,
         ICM   R4,15,WrkDSECT@     A(1st DSECT Entry)
         JZ    BuildXit            B. If Not Built
         ST    R4,WrkDSCUR@
         USING DSECTMAP,R4
         MVC   WRKPUNCH,BLANKS

         GOIF  $PRINT,OFF=Buil0100 B. If PRINT= Not Specified
         MVC   WRKPUNCH+9(11),=C'PUSH  PRINT'
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         MVC   WRKPUNCH+9(5),=C'PRINT'
         MVC   WRKPUNCH+15(8),WPRINT
         LA    R1,WRKPUNCH
         #ICALL PUNCH

Buil0100 DS    0H
         GOIF  $NAME,OFF=Buil0200
         MVC   WRKPUNCH(8),WRKNAME
Buil0200 DS    0H
         MVC   WRKPUNCH+9(8),=C'DS    0D'
         GOIF  $CSECT,OFF=Buil0300
         MVC   WRKPUNCH+9(8),=C'CSECT , '
Buil0300 DS    0H
         LA    R1,WRKPUNCH
         #ICALL PUNCH

         MVC   WRKPUNCH+9(17),=C'BLSQMDEF BASELBL='
         MVC   WRKPUNCH+26(45),DSECTLAB
         CLI   DSECTLAB+44,C' '    Check For Really Long Label
         JNE   Buil0400            B. If Yes
         TRT   WRKPUNCH+26(80),BLANKTAB
         MVI   0(R1),C','
Buil0400 DS    0H
         MVI   WRKPUNCH+71,C'*'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

         CLI   DSECTLAB+44,C' '    Check For Really Long Label
         JE    Buil0500            B. If Not (No Second Stmt. Required)
         MVC   WRKPUNCH+15(19),DSECTLAB+45
         TRT   WRKPUNCH+15(80),BLANKTAB
         MVI   0(R1),C','
         MVI   WRKPUNCH+71,C'*'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

Buil0500 DS    0H
         MVC   WRKPUNCH+15(8),=C'CBLEN=X'''
         MVC   WRKPUNCH+23(5),DSECTL
         GOIF  $CBLEN,OFF=Buil0600
         MVC   WRKPUNCH+23(5),WRKCBLEN+1
Buil0600 DS    0H
         MVC   WRKPUNCH+28(11),=C''',PREFIX=0,'
         MVI   WRKPUNCH+71,C'*'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

         GOIF  $HEADER,OFF=Buil0700
         MVC   WRKPUNCH+15(7),=C'HEADER='
         MVC   WRKPUNCH+22(8),WHEADER
         TRT   WRKPUNCH+22(80),BLANKTAB
         MVI   0(R1),C','
         MVI   WRKPUNCH+71,C'*'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

Buil0700 DS    0H
         #ICALL FindACROLBL        Find Acronym Label
         LTR   R15,R15             Check If Acronym Found
         JNZ   Buil1100            B. If Not

         MVC   WRKPUNCH+15(7),=C'ACROFF='
         MVC   WRKPUNCH+22(6),WACROFF
         MVC   WRKPUNCH+28(9),=C',ACROLEN='
         MVC   WRKPUNCH+37(5),WACROLEN
         MVI   WRKPUNCH+42,C','
         GOIF  $OFFSETS,OFF=Buil0800
         CLC   WRKOFFS,=CL7'PRINT'
         JE    Buil0800            B. If Set To Default
         MVC   WRKPUNCH+43(8),=C'OFFSETS='
         MVC   WRKPUNCH+51(7),WRKOFFS
         TRT   WRKPUNCH+51(80),BLANKTAB
         MVI   0(R1),C','
Buil0800 DS    0H
         MVI   WRKPUNCH+71,C'*'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

         MVC   WRKPUNCH+15(8),=C'ACROLBL='
         MVC   WRKPUNCH+23(48),WACROLBL
         CLI   WACROLBL+47,C' '    Check For Really Long Label
         JNE   Buil0900            B. If Yes
         TRT   WRKPUNCH+23(80),BLANKTAB
         MVI   0(R1),C','
         AHI   R1,1                A(End Of ACROLBL=)
         LA    R2,WRKPUNCH+70      A(End Of Current Line)
         SR    R2,R1               Calculate Remaining Length
         CHI   R2,17               Check If Room For ACRONYM=
         JL    Buil0900            B. If Not
         MVC   0(8,R1),=C'ACRONYM='
         MVC   8(L'WACRONYM,R1),WACRONYM
         TRT   8(L'WACRONYM+1,R1),BLANKTAB
         MVI   0(R1),C','
         MVI   WRKPUNCH+71,C'*'
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         J     Buil1100

Buil0900 DS    0H
         MVI   WRKPUNCH+71,C'*'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

         CLI   WACROLBL+47,C' '    Check For Really Long Label
         JE    Buil1000            B. If Not (No Second Stmt. Required)
         MVC   WRKPUNCH+15(16),WACROLBL+48
         TRT   WRKPUNCH+15(80),BLANKTAB
         MVI   0(R1),C','
Buil1000 DS    0H
         TRT   WRKPUNCH+15(80),BLANKTAB
         MVC   0(8,R1),=C'ACRONYM='
         MVC   8(L'WACRONYM,R1),WACRONYM
         TRT   8(L'WACRONYM+1,R1),BLANKTAB
         MVI   0(R1),C','
         MVI   WRKPUNCH+71,C'*'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

Buil1100 DS    0H
         MVC   WRKPUNCH+15(8),=C'MAINTLV='
         MVC   WRKPUNCH+23(8),WRKMAINT
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         J     Buil3500

Buil1200 DS    0H
         ST    R4,WrkDSCUR@
         #ICALL TRACE

         CLC   =C'ORG ',DSECTOPC
         JE    Buil3500
         CLC   =C'USING ',DSECTOPC
         JE    Buil3500
         CLC   =C'CSECT ',DSECTOPC
         JE    Buil3700            B. If End Of DSECT
         CLC   =C'DSECT ',DSECTOPC
         JE    Buil3700            B. If End Of DSECT
         CLC   =C'RSECT ',DSECTOPC
         JE    Buil3700            B. If End Of DSECT
         CLC   DSECTL,=C'00000'
         JE    Buil3500
         CLC   DSECTVAL,BLANKS
         JNE   Buil1300
         CLC   DSECTL,BLANKS
         JNE   Buil1300
         J     Buil3500

Buil1300 DS    0H
         CLC   DSECTOFF,BLANKS     Check For Label With Offset
         JE    Buil3400            B. If Not

         GOIF  $CBLEN,OFF=Buil1400
         MVC   NUMBER,DSECTOFF
         #ICALL CONVHEX            Convert Offset To Hex
         L     R2,WRKHEX           Load Current Entry's OFFSET
         MVC   NUMBER,WRKCBLEN
         #ICALL CONVHEX            Convert Offset To Hex
         CL    R2,WRKHEX           Check If Entry Past End Of DSECT
         JNL   Buil3700            B. If Yes

Buil1400 DS    0H
         LHI   R0,1                Load Exit Call Number
         LA    R1,DSECTMAP         A(Current Record)
         #ICALL USEREXIT           Call Exit Routine
         LTR   R15,R15             Check If Line To Be Skipped
         JNZ   Buil3500            B. If Yes

         GOIF  $NO_RSV,OFF=Buil1500
         CLI   DSECTLAB,C'*'
         JNE   Buil1500            B. If Labelled Field
         CLI   DSECTFL2,0          Check Flag Settings
         JE    Buil3500            B. If No Flags
         MVC   DSECTL,=C'00000'    Set Length To Zero
         OI    DSECTFL2,DSECT$XL   Set "NOLABEL" Due To NO_RSV

Buil1500 DS    0H
         MVC   WRKPUNCH+9(14),=C'BLSQMFLD NAME='
         MVC   WRKPUNCH+23(48),DSECTLAB
         MVI   WRKPUNCH+71,C'*'

         CLI   DSECTLAB+47,C' '    Check For Really Long Label
         JE    Buil1600            B. If Not
         LA    R1,WRKPUNCH
         #ICALL PUNCH              Output 1st Half Of NAME=
         MVC   WRKPUNCH+15(16),DSECTLAB+48
         TRT   WRKPUNCH+15(80),BLANKTAB
         J     Buil1800

Buil1600 DS    0H
         CLI   WRKPUNCH+41,C' '    Check If Room For Options
         JE    Buil1700            B. If Yes
         TRT   WRKPUNCH+19(80),BLANKTAB
         MVI   0(R1),C','
         LA    R1,WRKPUNCH
         #ICALL PUNCH              Output NAME= Keyword
         LA    R6,WRKPUNCH+15      A(Start Of Next Line)
         J     Buil1900            Continue

Buil1700 DS    0H
         TRT   WRKPUNCH+19(80),BLANKTAB
Buil1800 DS    0H
         MVI   0(R1),C','
         LA    R6,1(,R1)

Buil1900 DS    0H
         TM    DSECTFL2,DSECT$AE   "ARRAY=END" From USEREXIT ?
         JZ    Buil2000            B. If Not
         MVC   0(10,R6),=C'ARRAY=END,'
         AHI   R6,10

Buil2000 DS    0H
         TM    DSECTFL2,DSECT$DC   "DECODE" From USEREXIT ?
         JZ    Buil2100            B. If Not
         MVC   0(7,R6),=C'DECODE,'
         AHI   R6,7

Buil2100 DS    0H
         TM    DSECTFL2,DSECT$NL   "NEWLINE" From USEREXIT ?
         JO    Buil2200            B. If Yes
         TM    WRKFLAG,W$NEWLINE   "NEWLINE" Needed ?
         JZ    Buil2300            B. If Not
Buil2200 DS    0H
         MVC   0(8,R6),=C'NEWLINE,'
         AHI   R6,8
         NI    WRKFLAG,255-W$NEWLINE

Buil2300 DS    0H
         TM    DSECTFL2,DSECT$ST   "STACK" From USEREXIT ?
         JZ    Buil2400            B. If Not
         MVC   0(6,R6),=C'STACK,'
         AHI   R6,6

Buil2400 DS    0H
         TM    DSECTFL2,DSECT$XL   "NOLABEL" Due To NO_RSV ?
         JZ    Buil2500            B. If Not
         MVC   0(8,R6),=C'NOLABEL,'
         AHI   R6,8

Buil2500 DS    0H
         CLC   WRKPUNCH+15(56),BLANKS
         JE    Buil2600            B. If Null Line
         MVI   WRKPUNCH+71,C'*'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

Buil2600 DS    0H
         CLI   DSECTLAB,C'*'
         JE    Buil2700
         CLI   DSECTLAB,C' '
         JE    Buil2700
         #ICALL NAME8              Create 8 Byte NAME= Field
         CLC   WNAME8(8),DSECTLAB  LABEL= Same As NAME= ?
         JE    Buil2700            B. If Yes
         TRT   WRKPUNCH+15(80),BLANKTAB
         MVC   0(6,R1),=C'LABEL='
         MVC   6(L'WNAME8,R1),WNAME8
         TRT   WRKPUNCH+15(80),BLANKTAB
         MVI   0(R1),C','
Buil2700 DS    0H
         CLC   WRKPUNCH+15(50),BLANKS
         JE    Buil2800
         MVI   WRKPUNCH+71,C'*'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

Buil2800 DS    0H
         CLI   DSECTLAB,C'*'
         JE    Buil3000

         TM    DSECTFL1,DSECT$EB
         JZ    Buil2900
         MVC   WRKPUNCH+15(12),=C'DTYPE=EBCDIC'
         J     Buil3300
Buil2900 DS    0H
         TM    DSECTFL1,DSECT$HX
         JZ    Buil3200
         MVC   NUMBER,DSECTOFF
         #ICALL CONVHEX            Convert Offset To Hex
         L     R1,WRKHEX           Load Current Entry's OFFSET
         CL    R1,WrkStOff         Compare Current Offset
         JL    Buil3000            B. If Lower Than Starting Point
         CLC   DSECTL,=C'00001'
         JNE   Buil3100
         ICM   R15,15,DSECTNXT     A(Next Entry)
         JZ    Buil3100            B. If End Of DSECT
         CLC   =C'EQU ',DSECTOPC-DSECTMAP(R15)
         JNE   Buil3100
         CLC   =C'000',DSECTVAL-DSECTMAP(R15)
         JNE   Buil3100
         MVC   WRKPUNCH+15(22),=C'DTYPE=HEX,VIEW=X''8200'''
         OI    DSECTFL1,DSECT$DE   Add DECODE For This Label
         J     Buil3300
Buil3000 DS    0H
         MVC   WRKPUNCH+15(18),=C'DTYPE=HEX,VIEW=(8)'
         J     Buil3300
Buil3100 DS    0H
         MVC   WRKPUNCH+15(9),=C'DTYPE=HEX'
         J     Buil3300
Buil3200 DS    0H
         TM    DSECTFL1,DSECT$AN
         JZ    Buil3300
         MVC   WRKPUNCH+15(9),=C'DTYPE=ANY'
Buil3300 DS    0H
         TRT   WRKPUNCH+15(80),BLANKTAB
         MVI   0(R1),C','
         MVI   WRKPUNCH+71,C'*'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

         MVC   WRKPUNCH+15(6),=C'OFF=X'''
         MVC   WRKPUNCH+21(6),DSECTOFF
         MVC   WRKPUNCH+27(6),=C''',LEN='
         MVC   WRKPUNCH+33(5),DSECTL
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         J     Buil3500

Buil3400 DS    0H
         CLC   =C'EQU ',DSECTOPC
         JE    Buil3500
         MVC   WRKPUNCH(7),=C'-Error-'
         MVC   WRKPUNCH+8(4),=C'OFF='
         MVC   WRKPUNCH+12(6),DSECTOFF
         MVC   WRKPUNCH+19(4),=C'VAL='
         MVC   WRKPUNCH+23(5),DSECTVAL
         MVC   WRKPUNCH+29(2),=C'L='
         MVC   WRKPUNCH+31(5),DSECTL
         MVC   WRKPUNCH+37(4),=C'OPC='
         MVC   WRKPUNCH+41(8),DSECTOPC
         MVC   WRKPUNCH+50(4),=C'LAB='
         MVC   WRKPUNCH+54(64),DSECTLAB
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         #SETRC 8                  Set Return Code

Buil3500 DS    0H
         ICM   R4,15,DSECTNXT      A(Next DSECT entry)
         JZ    Buil3700            B. If End Of DSECT
         GOIF  $START,OFF=Buil3600 Check For START= Keyword
         CLC   DSECTLAB,WSTART     Check For Starting Label
         JNE   Buil3500            B. If Not (Keep Searching)
         SET   $START,OFF
Buil3600 DS    0H
         J     Buil1200            Process This Entry

Buil3700 DS    0H
         LA    R1,WRKPUNCH
         #ICALL PUNCH

         GOIF  $DECODE,OFF=Buil4000
         ICM   R4,15,WrkDSECT@     A(1st DSECT Entry)
         JZ    Buil4000
         NI    WRKFLAG,255-W$DECODE
Buil3800 DS    0H
         ICM   R4,15,DSECTNXT      A(Next DSECT Entry)
         JZ    Buil3900            B. If End Of DSECT
         TM    DSECTFL1,DSECT$DE   Check If DECODE Statement Required
         JZ    Buil3800            B. If Not
         OI    WRKFLAG,W$DECODE    Remember DECODE Statement Added
         MVC   DSECTDCL(3),WSUBHDR Save ACRONYM/PREFIX Prefix
         MVI   DSECTDCL+3,C'D'     Identify "DECODE" Label
         L     R15,WDECODE#
         AHI   R15,1               Increment "DECODE" Label Number
         ST    R15,WDECODE#
         CVD   R15,WRKDBL1
         OI    WRKDBL1+7,X'0F'
         UNPK  DSECTDCL+4(4),WRKDBL1+4(4)
         MVC   WRKPUNCH+9(14),=C'BLSQMFLD NAME='
         MVC   WRKPUNCH+23(8),DSECTDCL
         MVC   WRKPUNCH+31(7),=C',OFF=X'''
         MVC   WRKPUNCH+38(6),DSECTOFF
         MVC   WRKPUNCH+44(27),=C''',LEN=1,VIEW=X''0280'',DECODE'
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         J     Buil3800

Buil3900 DS    0H
         TM    WRKFLAG,W$DECODE    Check If Any DECODE Statements Added
         JZ    Buil4000            B. If Not
         GOIF  $SFOOTER,OFF=Buil4100
         LA    R1,WRKPUNCH
         #ICALL PUNCH

*        Add SHDR= Entry For Footer Information
Buil4000 DS    0H
         GOIF  $SFOOTER,OFF=Buil4100
         MVC   WRKPUNCH+9(L'@SHEADER),@SHEADER
         MVC   WRKPUNCH+24(3),WSUBHDR
         MVC   WRKPUNCH+27(4),=C'SFTR'
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         LA    R1,WRKPUNCH
         #ICALL PUNCH

Buil4100 DS    0H
         LHI   R0,3                Load Exit Call Number
         LA    R1,DSECTMAP         A(Current Record)
         #ICALL USEREXIT           Call Exit Routine

         MVC   WRKPUNCH+9(12),=C'BLSQMDEF END'
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         LA    R1,WRKPUNCH
         #ICALL PUNCH

         LHI   R0,2                Load Exit Call Number
         LA    R1,DSECTMAP         A(Current Record)
         #ICALL USEREXIT           Call Exit Routine

*        Add BLSQSHDR Statement For Headers & Footers
Buil4200 DS    0H
         GOIF  ($SHEADER,$SFOOTER),OFF=Buil4500

         GOIF  $SHEADER,OFF=Buil4300
         MVI   WRKPUNCH,C'$'
         MVC   WRKPUNCH+1(3),WSUBHDR
         MVC   WRKPUNCH+4(4),=C'SHDR'
         MVC   WRKPUNCH+9(10),=C'BLSQSHDR '''
         MVC   WRKPUNCH+19(50),WSHEADER
         MVI   WRKPUNCH+69,C''''
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         OI    WRKFLAG,W$NEWLINE   "NEWLINE" Needed for next BLSQMFLD

Buil4300 DS    0H
         GOIF  $SFOOTER,OFF=Buil4400
         MVI   WRKPUNCH,C'$'
         MVC   WRKPUNCH+1(3),WSUBHDR
         MVC   WRKPUNCH+4(4),=C'SFTR'
         MVC   WRKPUNCH+9(10),=C'BLSQSHDR '''
         MVC   WRKPUNCH+19(50),WSFOOTER
         MVI   WRKPUNCH+69,C''''
         LA    R1,WRKPUNCH
         #ICALL PUNCH

Buil4400 DS    0H
         LA    R1,WRKPUNCH
         #ICALL PUNCH

Buil4500 DS    0H
         GOIF  $DECODE,OFF=Buil5600
         ICM   R4,15,WrkDSECT@     A(1st DSECT Entry)
         JZ    Buil5600
         NI    WRKFLAG,255-W$DECODE
Buil4600 DS    0H
         ICM   R4,15,DSECTNXT      A(Next DSECT Entry)
         JZ    Buil5600            B. If End Of DSECT

Buil4700 DS    0H
         TM    DSECTFL1,DSECT$DE   Check If DECODE Statement Required
         JZ    Buil4600            B. If Not
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         OI    WRKFLAG,W$DECODE    Remember DECODE Statement Added
         MVC   WRKPUNCH(8),DSECTDCL Insert DECODE Label
         MVC   WRKPUNCH+9(L'BuilRec1),BuilRec1
         TM    DSECTFL2,DSECT$VM   "VIEWMATCH=VALUE" From Exit ?
         JZ    Buil4750            B. If Not
         MVC   WRKPUNCH+0+L'BuilRec1(16),=C',VIEWMATCH=VALUE'

Buil4750 DS    0H
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         MVC   WrkEQU@,DSECTNXT    Save 1st EQU Address
         MVC   WrkEQUL,DSECTLAB    Save Flag Label
         NI    WRKFLAG,255-W$LABEL Label Line Not Written Yet
Buil4800 DS    0H
         ICM   R4,15,DSECTNXT      A(Next DSECT Entry)
         JZ    Buil4900            B. If End Of DSECT
         MVC   DSECTDCL(3),WSUBHDR Save ACRONYM/PREFIX Prefix
         MVI   DSECTDCL+3,C'S'     Identify "SHDR" Label
         L     R15,WSUBHDR#
         AHI   R15,1               Increment "SHDR" Label Number
         ST    R15,WSUBHDR#
         CVD   R15,WRKDBL1
         OI    WRKDBL1+7,X'0F'
         UNPK  DSECTDCL+4(4),WRKDBL1+4(4)

         TM    WRKFLAG,W$LABEL     Label Line Written Yet ?
         BO    Buil4850            B. If Yes
         MVC   WRKPUNCH+9(L'BuilRec2),BuilRec2
         MVC   WRKPUNCH+23(8),DSECTDCL
         MVI   WRKPUNCH+26,C'L'    Change "...S...." To "...L...."
         MVC   BuilRec3(8),WRKPUNCH+23
         MVC   BuilRec3+19(8),WrkEQUL
         MVI   BuilRec3+27,C' '
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         OI    WRKFLAG,W$LABEL

Buil4850 DS    0H
         MVC   WRKPUNCH+9(14),=C'BLSQMFLD SHDR='
         MVC   WRKPUNCH+23(8),DSECTDCL
         MVC   WRKPUNCH+31(21),=C',VIEW=X''__08'',NEWLINE'
         MVC   WRKPUNCH+39(2),DSECTVAL+3
         NI    WRKFLAG,255-W$NEWLINE
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         ICM   R15,15,DSECTNXT     A(Next Entry)
         JZ    Buil4900            B. If End Of DSECT
         CLC   =C'EQU ',DSECTOPC-DSECTMAP(R15)
         JE    Buil4800            B. If More EQU Statements

Buil4900 DS    0H
         TM    WRKFLAG,W$DECODE    Check If Any SHDR Statements Added
         JZ    Buil5500            B. If Not
         LHI   R0,3                Load Exit Call Number
         LA    R1,DSECTMAP         A(Current Record)
         #ICALL USEREXIT           Call Exit Routine

         MVC   WRKPUNCH+9(12),=C'BLSQMDEF END'
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         LA    R1,WRKPUNCH
         #ICALL PUNCH

         ICM   R4,15,WrkEQU@       A(1st EQU Statement)
         JZ    Buil5500
         MVC   WRKPUNCH(L'BuilRec3),BuilRec3
         LA    R1,WRKPUNCH
         #ICALL PUNCH
Buil5000 DS    0H
         MVC   WRKPUNCH(8),DSECTDCL Insert SHDR Label
         MVC   WRKPUNCH+9(10),=C'BLSQSHDR '''
         MVC   WRKPUNCH+19(L'DSECTLAB),DSECTLAB
         TRT   WRKPUNCH+27(80),BLANKTAB
         CLI   DSECTCOM,C'-'       Check If Comment Begins with "-"
         JNE   Buil5100            B. If Not
         SHI   R1,2                Back Up To Allow +3 Move
         J     Buil5200            Continue
Buil5100 DS    0H
         MVI   1(R1),C'-'
Buil5200 DS    0H
         MVC   3(65,R1),DSECTCOM
         LAY   R15,TRTABLE2
         TR    3(70,R1),0(R15)     Convert Quotes Etc.
         MVC   WRKPUNCH+70(20),BLANKS
         LA    R2,WRKPUNCH+70      A(Last valid Byte)
Buil5300 DS    0H
         CLI   0(R2),C' '          Check For Final Blank
         JNE   Buil5400            B. If Last Character Found
         BRCT  R2,Buil5300         Back Up Till Non-Blank Found
Buil5400 DS    0H
         MVI   1(R2),C''''
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         ICM   R4,15,DSECTNXT      A(Next Entry)
         JZ    Buil5600            B. If End Of DSECT
         CLC   =C'EQU ',DSECTOPC
         JE    Buil5000            B. If More EQU Statements
Buil5500 DS    0H
         LTR   R4,R4               Check If We Hit The End
         JNZ   Buil4700            B. If Not

Buil5600 DS    0H
         GOIF  $PRINT,OFF=Buil5800 B. If PRINT= Not Specified
         GOIF  $PTF,OFF=Buil5700   B. If PTF= Not Specified
         MVC   WRKPUNCH,BLANKS
         LA    R1,WRKPUNCH
         #ICALL PUNCH
         MVC   WRKPUNCH+9(12),=C'#TMMOD# PTF='
         MVC   WRKPUNCH+21(8),WRKPTFID
         LA    R1,WRKPUNCH
         #ICALL PUNCH
Buil5700 DS    0H
         MVC   WRKPUNCH+9(11),=C'POP   PRINT'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

Buil5800 DS    0H
         GOIF  $END,OFF=Buil5900   B. If END Not Specified
         MVC   WRKPUNCH+9(7),=C'END   ,'
         LA    R1,WRKPUNCH
         #ICALL PUNCH

Buil5900 DS    0H
         LHI   R15,0

BuildXit #IPEND ,

         #CON  RESUME
BuilRec1 DC    C'BLSQMDEF CBLEN=1,OFFSETS=NOPRINT,PREFIX=0'
BuilRec2 DC    C'BLSQMFLD SHDR=___Lnnnn,VIEW=X''FF00'',NEWLINE'
BuilRec3 DC    C'___Lnnnn BLSQSHDR ''________ -------------------------*
               -----------------'''
         #CON  REVERT

*---------------------------------------------------------------------*
*                                                                     *
*        Parse Input Parameter List                                   *
*                                                                     *
*---------------------------------------------------------------------*
ParseParm #IPROC ,

         MVC   WrkStOff,=F'0'      Set Default DECODE=
         #ICALL GetDate            Get Current MAINTLV=
         MVC   WRKOFFS,=CL7'PRINT' Set Default OFFSETS=
         MVC   WPRINT,=CL8'GEN'    Set Default PRINT=

         L     R1,WRKPARM@         A(Input Paramters)
         ICM   R3,15,0(R1)         A(Parameter List)
         JZ    ParsErr1
         LA    R3,0(,R3)           Clear High Order Bit
         SLR   R2,R2
         ICM   R2,3,0(R3)          L(Parameter Text)
         JZ    ParsErr1
         AHI   R3,2                A(Parameter Text)
         ST    R2,WRKPARML         Save Parameter List Length
         CHI   R2,255              Check For Maximum Length
         JNH   Pars0100            B. If Acceptable Length
         LHI   R2,255              Set To Maximum (for Print Data)
Pars0100 DS    0H
         MVC   WRKPARM,BLANKS      Clear Macro Name Field
         #EXEC -R2,MVC,WRKPARM(*-*),0(R3)
         L     R2,WRKPARML         Restore Original Parm Length
         J     Pars0300

Pars0200 DS    0H
         SHI   R2,1                Subtract 1 From Remaining Length
         AHI   R3,1                Advance To Next Character

Pars0300 DS    0H
         LTR   R2,R2               Check If Parsing Complete
         JNP   Pars0800            B. If Yes
         CLI   0(R3),C' '          Check For Blank
         JE    Pars0200            B. If Yes (Skip It)
         CLI   0(R3),C','          Check For Comma
         JE    Pars0200            B. If Yes (Skip It)

         LAY   R4,ParmTbl          A(Valid PARM= Keywords)
Pars0400 DS    0H
         CLI   0(R4),X'FF'         Check For End Of Table
         JE    ParsErr2            B. If Operand Not Found

         CH    R2,0(,R4)           Check If Keyword Fits
         JL    Pars0700            B. If Not
         LH    R5,0(,R4)           Load Keyword Length
         #EXEC -R5,CLC,0(*-*,R3),6(R4)
         JNE   Pars0700            B. If No Match For Keyword

         SH    R2,0(,R4)           Subtract Keyword Length
         AH    R3,0(,R4)           Advance Past Keyword
         LR    R5,R2               Save Remaining Length

         LTR   R2,R2               Check For End Of Parameter List
         JZ    Pars0600            B. If Yes

         CLI   0(R3),C''''         Check If Operand within Quotes
         JE    Pars0500            B. If Yes
         LA    R1,0(R2,R3)         A(End Of Parameter List)
         LAY   R15,TRTABLE1
         #EXEC -R2,TRT,0(*-*,R3),0(R15)
         SR    R1,R3               Calculate Length Of Operand
         LR    R2,R1               Pass Length To Subroutine
         J     Pars0600

Pars0500 DS    0H
         LA    R1,0(R2,R3)         A(End Of Parameter List)
         SHI   R2,1                Subtract 1 For Leading Quote
         LAY   R15,TRTABLE3
         #EXEC -R2,TRT,1(*-*,R3),0(R15)
         AHI   R1,1                Point Past Trailing Quote
         SR    R1,R3               Calculate Length Of Operand
         LR    R2,R1               Pass Length To Subroutine

Pars0600 DS    0H
         ICM   R10,15,2(R4)        A(Keyword Subroutine)
         BASR  R10,R10             Process Operand

         SR    R5,R2               Calculate Remaining Length
         AR    R3,R2               Advance Past Operand
         LR    R2,R5               Restore Length Register

         J     Pars0300            Continue Processing Parmameters

Pars0700 DS    0H
         AHI   R4,ParmTblL         A(Next PARM= Table Entry)
         J     Pars0400            Continue Processing Table

*        Ensure "BASELBL" Was Specified
Pars0800 DS    0H
         GOIF  $BASELBL,OFF=ParsErr1 Ensure DSECT= Specified

*        Ensure "ACRONYM" Or "PREFIX" coded to generate a unique label
         GOIF  $LABEL,ON=Pars0900    Use LABEL= when Specified
         GOIF  ($ACRONYM,$PREFIX),NONE=ParsErr6
         MVC   WSUBHDR,WACRONYM
         GOIF  $ACRONYM,ON=Pars0900  Use ACRONYM= Prefix
         MVC   WSUBHDR,WPREFIX
Pars0900 DS    0H
         CLI   WSUBHDR+1,C' '        Check For Single Character Prefix
         JNE   Pars1000              B. If Not
         MVI   WSUBHDR+1,C'$'        Insert Prefix Filler
Pars1000 DS    0H
         CLI   WSUBHDR+2,C' '        Check For Double Character Prefix
         JNE   ParseRC0              B. If Not
         MVI   WSUBHDR+2,C'$'        Insert Prefix Filler
         J     ParseRC0

ParsErr1 DS    0H
         MVC   WrkTemp(ErrMsg01L),ErrMsg01
         WTO   TEXT=WrkTemp
         J     ParseRC8
ParsErr2 DS    0H
         MVC   WrkTemp(ErrMsg02L),ErrMsg02
         MVC   ErrMsg02A+WrkTemp,BLANKS
         CHI   R2,8
         JNH   ParsEr2A
         LHI   R2,8
ParsEr2A DS    0H
         #EXEC -R2,MVC,ErrMsg02A+WrkTemp(*-*),0(R3)
         WTO   TEXT=WrkTemp
         J     ParseRC8
ParsErr3 DS    0H
         MVC   WrkTemp(ErrMsg03L),ErrMsg03
         MVC   ErrMsg03A+WrkTemp,6(R4)
         WTO   TEXT=WrkTemp
         J     ParseRC8
ParsErr4 DS    0H
         MVC   WrkTemp(ErrMsg04L),ErrMsg04
         MVC   ErrMsg04A+WrkTemp,6(R4)
         WTO   TEXT=WrkTemp
         J     ParseRC8
ParsErr5 DS    0H
         MVC   WrkTemp(ErrMsg05L),ErrMsg05
         MVC   ErrMsg05A+WrkTemp,6(R4)
         WTO   TEXT=WrkTemp
         J     ParseRC8
ParsErr6 DS    0H
         MVC   WrkTemp(ErrMsg06L),ErrMsg06
         WTO   TEXT=WrkTemp
         J     ParseRC8

ParseRC0 DS    0H
         LHI   R15,0               Set Return Code
         J     ParsExit

ParseRC8 DS    0H
         LHI   R15,8               Set Return Code
         J     ParsExit

ParmTbl  DS    0H
         DC    AL2(03),AL4(Prtn01),CL10'AL='
ParmTblL EQU   *-ParmTbl
         DC    AL2(08),AL4(Prtn01),CL10'ACROLBL='
         DC    AL2(03),AL4(Prtn02),CL10'AN='
         DC    AL2(08),AL4(Prtn02),CL10'ACRONYM='
         DC    AL2(03),AL4(Prtn03),CL10'BA='
         DC    AL2(08),AL4(Prtn03),CL10'BASELBL='
         DC    AL2(03),AL4(Prtn04),CL10'CB='
         DC    AL2(06),AL4(Prtn04),CL10'CBLEN='
         DC    AL2(05),AL4(Prtn05),CL10'CSECT'
         DC    AL2(03),AL4(Prtn06),CL10'DE='
         DC    AL2(07),AL4(Prtn06),CL10'DECODE='
         DC    AL2(03),AL4(Prtn07),CL10'END'
         DC    AL2(05),AL4(Prtn08),CL10'NOEND'
         DC    AL2(03),AL4(Prtn09),CL10'HE='
         DC    AL2(07),AL4(Prtn09),CL10'HEADER='
         DC    AL2(05),AL4(Prtn10),CL10'LAST8'
         DC    AL2(03),AL4(Prtn11),CL10'LA='
         DC    AL2(06),AL4(Prtn11),CL10'LABEL='
         DC    AL2(03),AL4(Prtn12),CL10'ML='
         DC    AL2(08),AL4(Prtn12),CL10'MAINTLV='
         DC    AL2(03),AL4(Prtn13),CL10'NA='
         DC    AL2(05),AL4(Prtn13),CL10'NAME='
         DC    AL2(03),AL4(Prtn14),CL10'OF='
         DC    AL2(08),AL4(Prtn14),CL10'OFFSETS='
         DC    AL2(03),AL4(Prtn15),CL10'PF='
         DC    AL2(07),AL4(Prtn15),CL10'PREFIX='
         DC    AL2(03),AL4(Prtn16),CL10'PR='
         DC    AL2(06),AL4(Prtn16),CL10'PRINT='
         DC    AL2(03),AL4(Prtn17),CL10'SH='
         DC    AL2(08),AL4(Prtn17),CL10'SHEADER='
         DC    AL2(03),AL4(Prtn18),CL10'SF='
         DC    AL2(08),AL4(Prtn18),CL10'SFOOTER='
         DC    AL2(03),AL4(Prtn19),CL10'ST='
         DC    AL2(06),AL4(Prtn19),CL10'START='
         DC    AL2(06),AL4(Prtn20),CL10'NO_RSV'
         DC    AL2(04),AL4(Prtn21),CL10'PTF='
         DC    AL2(-1)             End Of Table

*        ACROLBL=
Prtn01   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $ACROLBL,ON=ParsErr3 Check If Already Specified
         SET   $ACROLBL            Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,L'WACROLBL       Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         MVC   WACROLBL,BLANKS
         #EXEC -R2,MVC,WACROLBL(*-*),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        ACRONYM=
Prtn02   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $ACRONYM,ON=ParsErr3 Check If Already Specified
         SET   $ACRONYM            Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,8                Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         MVC   WACRONYM,BLANKS
         #EXEC -R2,MVC,WACRONYM(*-*),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        BASELBL=
Prtn03   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $BASELBL,ON=ParsErr3 Check If Already Specified
         SET   $BASELBL            Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,50               Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         STC   R2,WrkDSECTL
         MVC   WrkDSECT,BLANKS
         #EXEC -R2,MVC,WrkDSECT(*-*),0(R3)

         GOIF  $PREFIX,ON=Prtn0310 B. If PREFIX= Already Coded
         MVC   WPREFIX,WrkDSECT    Default PREFIX= to BASELBL= Value

Prtn0310 DS    0H
         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        CBLEN=
Prtn04   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $CBLEN,ON=ParsErr3  Check If Already Specified
         SET   $CBLEN              Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,5                Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         LHI   R1,6                L(Output Field)
         SLR   R1,R2               Calculate Residual Offset
         LA    R1,WRKCBLEN(R1)     Offset To Starting Position
         MVC   WRKCBLEN,=C'000000'
         #EXEC -R2,MVC,0(*-*,R1),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        CSECT
Prtn05   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $CSECT,ON=ParsErr3  Check If Already Specified
         SET   $CSECT              Remember Keyword Specified
         SET   $END                Imply "END" Keyword

         LTR   R2,R2               Check Operand Length
         JNZ   ParsErr5            B. If Data Exists

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        DECODE=#
Prtn06   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $DECODE,ON=ParsErr3 Check If Already Specified
         SET   $DECODE             Remember Keyword Specified

         LTR   R5,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,8                Check For Maximum Length
         JH    ParsErr5            B. If Too Long

         #EXEC -R2,TRT,0(*-*,R3),NUMBERS
         JNZ   ParsErr5            B. If Not Numeric
         #EXEC -R5,PACK,WRKDBL1,0(*-*,R3)
         OI    WRKDBL1+7,X'0F'
         CVB   R1,WRKDBL1          Convert Number To Binary
         ST    R1,WrkStOff         Save Decoding Starting Point

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        END
Prtn07   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $CSECT,ON=Prtn0710  Check If CSECT= Specified
         GOIF  $END,ON=ParsErr3    Check If Already Specified
Prtn0710 DS    0H
         SET   $END                Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JNZ   ParsErr5            B. If Data Exists

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        NOEND
Prtn08   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         SET   $END,OFF            Turn OFF "END" Keyword

         LTR   R2,R2               Check Operand Length
         JNZ   ParsErr5            B. If Data Exists

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        HEADER=
Prtn09   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $HEADER,ON=ParsErr3 Check If Already Specified
         SET   $HEADER             Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,8                Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         MVC   WHEADER,BLANKS
         #EXEC -R2,MVC,WHEADER(*-*),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        LAST8
Prtn10   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $LAST8,ON=ParsErr3  Check If Already Specified
         SET   $LAST8              Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JNZ   ParsErr5            B. If Data Exists

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        LABEL=
Prtn11   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $LABEL,ON=ParsErr3 Check If Already Specified
         SET   $LABEL              Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,3                Check For Exact Length
         JNE   ParsErr5            B. If Not Correct
         MVC   WSUBHDR,BLANKS
         #EXEC -R2,MVC,WSUBHDR(*-*),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        MAINTLV=
Prtn12   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $MAINTLV,ON=ParsErr3 Check If Already Specified
         SET   $MAINTLV            Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,5                Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         MVC   WRKMAINT,BLANKS
         #EXEC -R2,MVC,WRKMAINT(*-*),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        NAME=
Prtn13   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $NAME,ON=ParsErr3   Check If Already Specified
         SET   $NAME               Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,8                Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         MVC   WRKNAME,BLANKS
         #EXEC -R2,MVC,WRKNAME(*-*),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        OFFSETS=
Prtn14   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $OFFSETS,ON=ParsErr3 Check If Already Specified
         SET   $OFFSETS            Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,5                Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         MVC   WRKOFFS,BLANKS
         #EXEC -R2,MVC,WRKOFFS(*-*),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        PREFIX=
Prtn15   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $PREFIX,ON=ParsErr3 Check If Already Specified
         SET   $PREFIX             Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,8                Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         STC   R2,WPREFIXL         Save PREFIX= Length
         MVC   WPREFIX,BLANKS
         #EXEC -R2,MVC,WPREFIX(*-*),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        PRINT=
Prtn16   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $PRINT,ON=ParsErr3 Check If Already Specified
         SET   $PRINT              Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,8                Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         MVC   WPRINT,BLANKS
         #EXEC -R2,MVC,WPRINT(*-*),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        SHEADER=
Prtn17   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $SHEADER,ON=ParsErr3 Check If Already Specified
         SET   $SHEADER            Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CLI   0(R3),C''''         Check If Enclosed Within Quotes
         JNE   Prtn1710            B. If Not
         AHI   R3,1                Point Past Leading Quote
         SHI   R2,2                Remove Quotes From Length
Prtn1710 DS    0H
         CHI   R2,50               Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         MVC   WSHEADER,BLANKS
         #EXEC -R2,MVC,WSHEADER(*-*),0(R3)
         LAY   R15,TRTABLE2
         TR    WSHEADER,0(R15)     Convert Quotes Etc.

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        SFOOTER=
Prtn18   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $SFOOTER,ON=ParsErr3 Check If Already Specified
         SET   $SFOOTER            Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CLI   0(R3),C''''         Check If Enclosed Within Quotes
         JNE   Prtn1810            B. If Not
         AHI   R3,1                Point Past Leading Quote
         SHI   R2,2                Remove Quotes From Length
Prtn1810 DS    0H
         CHI   R2,50               Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         MVC   WSFOOTER,BLANKS
         #EXEC -R2,MVC,WSFOOTER(*-*),0(R3)
         LAY   R15,TRTABLE2
         TR    WSFOOTER,0(R15)     Convert Quotes Etc.

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        START=
Prtn19   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $START,ON=ParsErr3  Check If Already Specified
         SET   $START              Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,50               Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         MVC   WSTART,BLANKS
         #EXEC -R2,MVC,WSTART(*-*),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        NO_RSV
Prtn20   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $NO_RSV,ON=ParsErr3 Check If Already Specified
         SET   $NO_RSV             Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JNZ   ParsErr5            B. If Data Exists

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

*        PTF=
Prtn21   DS    0H
         STM   R0,R15,ParseSA      Save All Registers
         GOIF  $PTF,ON=ParsErr3    Check If Already Specified
         SET   $PTF                Remember Keyword Specified

         LTR   R2,R2               Check Operand Length
         JZ    ParsErr4            B. If Missing
         CHI   R2,8                Check For Maximum Length
         JH    ParsErr5            B. If Too Long
         MVC   WRKPTFID,BLANKS
         #EXEC -R2,MVC,WRKPTFID(*-*),0(R3)

         LM    R0,R15,PARSESA      Restore All Registers
         BR    R10                 Return To Parser

ParsExit #IPEND ,

*---------------------------------------------------------------------*
*        Close Any File That Is Currently Open                        *
*---------------------------------------------------------------------*
CloseFiles #IPROC ,

         TM    DCBOFLGS-IHADCB+ASSEMBLY,DCBOFOPN
         JNO   Close100            B. If "ASSEMBLY" Is Not Open
         CLOSE (ASSEMBLY)

Close100 DS    0H
         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN
         JNO   Close200            B. If "SYSPUNCH" Is Not Open
         CLOSE (SYSPUNCH)

Close200 DS    0H
         TM    DCBOFLGS-IHADCB+SYSTRACE,DCBOFOPN
         JNO   ClosExit            B. If "SYSTRACE" Is Not Open
         CLOSE (SYSTRACE)

ClosExit #IPEND ,

*---------------------------------------------------------------------*
*                                                                     *
*        Open Required Files                                          *
*                                                                     *
*---------------------------------------------------------------------*
OpenFiles #IPROC ,

         OPEN  (ASSEMBLY,(INPUT),SYSPUNCH,(OUTPUT))

         TM    DCBOFLGS-IHADCB+ASSEMBLY,DCBOFOPN
         JNO   OpenRC08
         TM    DCBOFLGS-IHADCB+SYSPUNCH,DCBOFOPN
         JNO   OpenRC08

         LA    R2,DCBDDNAM-IHADCB+SYSTRACE
         TIOTSCAN DDN=(R2),NOK=Open0100
         OPEN  (SYSTRACE,(OUTPUT))
         TM    DCBOFLGS-IHADCB+SYSTRACE,DCBOFOPN
         JNO   OpenRC08
         SET   $TRACE              Write Trace Information To SYSTRACE

Open0100 DS    0H
         LHI   R15,0               Set Return Code
         J     OpenExit

OpenRC08 DS    0H
         LHI   R15,8               Set Return Code

OpenExit #IPEND ,

*---------------------------------------------------------------------*
*                                                                     *
*        Find The ACROLBL Label Within The DSECT                      *
*                                                                     *
*---------------------------------------------------------------------*
FindACROLBL #IPROC ,
         GOIF  $ACROLBL,OFF=FindARC8

         LA    R4,WrkDSECT@        A(1st DSECT Entry)
         USING DSECTMAP,R4
FindA100 DS    0H
         ICM   R4,15,DSECTNXT      A(Next DSECT Entry)
         JZ    FindARC8            B. If Entry Not Found
         CLC   DSECTLAB,WACROLBL
         JNE   FindA100            B. If Label Not Found

         MVC   WACROFF,DSECTOFF    Save Field Offset
         MVC   WACROLEN,DSECTL     Save Field Length

         LHI   R15,0               Set Return Code
         J     FindAxit

FindARC8 DS    0H
         LHI   R15,8               Set Return Code

FindAxit #IPEND ,

*---------------------------------------------------------------------*
*                                                                     *
*        Find The Label specified in the PARM                         *
*                                                                     *
*---------------------------------------------------------------------*
FindDsect #IPROC ,
         L     R5,WRKASM@          A(Assembler Output Buffer)
         ICM   R6,15,WRKASM#       #(Assembler Output Statements)
         JZ    Find0300
         LH    R2,WRKASMEL         L(Assembler Output Record)
*        Find The "DSECT" Statement
Find0100 DS    0H
         USING ASMLIST,R5
         CLC   ASMLOC,CZEROS       Check If Offset Is Zeros
         JNE   Find0200            B. If Not
         LA    R3,ASMLINE          A(Start Of Assembler Text)
         TRT   0(L'ASMLINE,R3),BLANKTAB
         JZ    Find0200            B. If No Blanks Found
         SR    R1,R3               Calculate Length Of Label
         JNP   Find0200            B. If No Label Exists
         STC   R1,WrkLabelL        Save Length Of Current Label
         MVC   WRKLABEL,BLANKS
         #EXEC -R1,MVC,WrkLabel(*-*),0(R3)

         LA    R3,1(R1,R3)         A(End Of Label)
         LA    R2,ASMLINE+L'ASMLINE-1
         SR    R2,R3               Calculate Remaining Output Length
         #EXEC -R2,TRT,0(*-*,R3),NBLANKTAB
         JZ    Find0200            B. If Non-Blank Not Found
         CLC   =C'DSECT ',0(R1)    Check For DSECT Line
         JNE   Find0200            B. If Not

         CLC   WrkDSECTL,WrkLabelL
         JNE   Find0200            B. If Not The Requested DSECT
         CLC   WrkDSECT,WrkLabel
         JNE   Find0200            B. If Not The Requested DSECT

         STORAGE OBTAIN,LENGTH=DSECTLEN,LOC=ANY,SP=1,CHECKZERO=YES
         ST    R1,WrkDSECT@        Save 1st Entry Address
         LR    R4,R1
         USING DSECTMAP,R4
         XC    DSECTPRE,DSECTPRE   Clear Previous Entry Pointer
         XC    DSECTNXT,DSECTNXT   Clear Next Entry Pointer
         MVC   DSECTPRL,BLANKS     Clear Previous DSECTLAB
         MVC   DSECTPRO,BLANKS     Clear Previous DSECTOFF
         MVC   DSECT,WRKNAME
         MVC   DSECTLAB,WrkLabel   Save DSECT Label
         MVC   DSECTOFF,ASMLOC     Save DSECT Offset (Zeros)
         MVC   DSECTVAL,ASMADDR1   Save DSECT Value  (Zeros)
         MVC   DSECTL,ASMADDR2     Save DSECT Length
         MVC   WrkDSELen,ASMADDR2  Save Dsect Length
         MVC   DSECTOPC,BLANKS
         MVC   DSECTOPC(5),=C'DSECT'
         MVC   DSECTOP,BLANKS
         MVC   DSECTCOM,BLANKS
         MVC   DSECTDCL,BLANKS
         J     Find1000

Find0200 DS    0H
         AH    R5,WRKASMEL         A(Next Assembler Statement)
         BRCT  R6,Find0100         B. If More Records

Find0300 DS    0H
         LHI   R15,8               Set Return Code
         J     FINDEXIT

*        Process statements within this DSECT
Find0400 DS    0H
         CLI   ASMLINE,C'*'        Check For Comment Statement
         JE    Find1000            B. If Yes (Ignore)
         CLC   =C'Symbol',ASMLOC   Check For Symbol Cross Reference
         JE    Find1200            B. If End Of Listing
         CLC   ASMSTMT,BLANKS      Check For Blank Statement Number
         JE    Find1000            B. If Yes
         TRT   ASMSTMT,NUMBERS     Check For Valid Statement Number
         JNZ   Find1000            B. If Not
         ST    R4,WRKPREV@         Save Previous DSECT Entry Address

         STORAGE OBTAIN,LENGTH=DSECTLEN,LOC=ANY,SP=1,CHECKZERO=YES
         ST    R1,DSECTNXT         Chain This Entry To Previous
         LR    R4,R1
         MVC   DSECTPRE,WRKPREV@   Set Previous Entry Pointer
         XC    DSECTNXT,DSECTNXT   Clear Next Entry Pointer
         MVC   DSECTPRL,BLANKS     Clear Previous DSECTLAB
         MVC   DSECTPRO,BLANKS     Clear Previous DSECTOFF
         MVC   DSECT,WRKNAME
         MVC   DSECTLAB,BLANKS
         MVI   DSECTLAB,C'*'
         MVC   DSECTOFF,ASMLOC     Save DSECT Offset
         MVC   DSECTVAL,ASMADDR1   Save DSECT Value
         MVC   DSECTL,ASMADDR2     Save DSECT Length
         MVC   DSECTOPC,BLANKS
         MVC   DSECTOP,BLANKS
         MVC   DSECTCOM,BLANKS
         MVC   DSECTDCL,BLANKS

         LA    R3,ASMLINE          A(Start Of Label)
         CLI   0(R3),C' '          Check If A Label Exists
         JE    Find0500            B. If Not
         TRT   0(L'ASMLINE,R3),BLANKTAB
         JZ    Find1000            B. If No Blanks Found
         SR    R1,R3               Calculate Length Of Label
         MVC   WrkTemp,Blanks
         #EXEC -R1,MVC,WrkTemp(*-*),0(R3)
         MVC   DSECTLAB,WrkTemp
         LA    R3,1(R1,R3)         A(End Of Label)

Find0500 DS    0H
         LA    R2,ASMLINE+L'ASMLINE-1
         SR    R2,R3               Calculate Remaining Output Length
         #EXEC -R2,TRT,0(*-*,R3),NBLANKTAB
         JZ    Find1000            B. If Non-Blank Not Found
         LR    R3,R1               A(DC/DS/EQU etc.)
         LA    R2,ASMLINE+L'ASMLINE-1
         SR    R2,R3               Calculate Remaining Output Length
         #EXEC -R2,TRT,0(*-*,R3),BLANKTAB
         SR    R1,R3               Calculate Length Of Label
         MVC   WrkTemp,Blanks
         #EXEC -R1,MVC,WrkTemp(*-*),0(R3)
         MVC   DSECTOPC,WrkTemp
         OC    DSECTOPC,BLANKS     Ensure Upper Case
         LA    R3,1(R1,R3)         A(End Of OptCode)

         LA    R2,ASMLINE+L'ASMLINE-1
         SR    R2,R3               Calculate Remaining Output Length
         #EXEC -R2,TRT,0(*-*,R3),NBLANKTAB
         JZ    Find1000            B. If Non-Blank Not Found
         LR    R3,R1               A(CLx ALx X'nn' etc.)
         LA    R2,ASMLINE+L'ASMLINE-1
         SR    R2,R3               Calculate Remaining Output Length
         #EXEC -R2,TRT,0(*-*,R3),BLANKTAB
         SR    R1,R3               Calculate Length Of Label
         MVC   WrkTemp,Blanks
         #EXEC -R1,MVC,WrkTemp(*-*),0(R3)
         MVC   DSECTOP,WrkTemp
         OC    DSECTOP,BLANKS      Ensure Upper Case
         LA    R3,1(R1,R3)         A(End Of Operand)

         CLC   =C'DC ',DSECTOPC    Check For Define Constant
         JNE   Find0600            B. If Not (No Need To Blank Value)
         MVC   DSECTVAL,BLANKS

Find0600 DS    0H
         CLC   =C'EQU ',DSECTOPC   Check For Equate Statement
         JNE   Find0900            B. If Not (No Need For Comments)
         LA    R2,ASMLINE+L'ASMLINE-1
         SR    R2,R3               Calculate Remaining Output Length
         #EXEC -R2,TRT,0(*-*,R3),NBLANKTAB
         JZ    Find1000            B. If Non-Blank Not Found
         LR    R3,R1               Comments
         LA    R2,ASMLINE+L'ASMLINE-1
         SR    R2,R3               Calculate Remaining Output Length
         CLI   0(R1),C'-'          Check For Lead "-"
         JE    Find0700            B. If Yes (Skip It)
         CLC   0(2,R1),=C'. '      Check For Lead "."
         JE    Find0700            B. If Yes (Skip It)
         J     Find0800
Find0700 DS    0H
         LA    R2,ASMLINE+L'ASMLINE-1
         SR    R2,R3               Calculate Remaining Output Length
         #EXEC -R2,TRT,0(*-*,R3),NBLANKTAB
         JZ    Find1000            B. If Non-Blank Not Found
         LR    R3,R1               Comments
         LA    R2,ASMLINE+L'ASMLINE-1
         SR    R2,R3               Calculate Remaining Output Length
Find0800 DS    0H
         MVC   WrkTemp,Blanks
         #EXEC -R2,MVC,WrkTemp(*-*),0(R3)
         MVC   DSECTCOM,WrkTemp
         J     Find1000

Find0900 DS    0H
         CLC   ASMLOC,WrkDSELen    Check If Last Statement Processed
         JE    Find1200
         CLC   =C'CSECT ',DSECTOPC Check For End Of DSECT
         JE    Find1100
         CLC   =C'DSECT ',DSECTOPC Check For End Of DSECT
         JE    Find1100
         CLC   =C'RSECT ',DSECTOPC Check For End Of DSECT
         JE    Find1100

Find1000 DS    0H
         AH    R5,WRKASMEL         A(Next Assembler Statement)
         BRCT  R6,Find0400         B. If More Records
         J     Find1200

Find1100 DS    0H
         L     R1,WRKPREV@         A(Previous DSECT) Entry
         XC    0(4,R1),0(R1)       Clear Last "DSECTNXT" Pointer
         STORAGE RELEASE,ADDR=(R4),LENGTH=DSECTLEN,SP=1

Find1200 DS    0H
         L     R4,WrkDSECT@        A(DSECT Entry)
         USING DSECTMAP,R4
Find1300 DS    0H
         ICM   R4,15,DSECTNXT      A(Next Entry)
         JZ    Find1900            B. If End Of DSECT
         CLC   DSECTOFF,BLANKS     Check If OFFSET Exists
         JE    Find1300            B. If Not
         CLI   DSECTLAB,C'*'       Check For Null Label
         JE    Find1500

         TRT   DSECTOP,NONNUMS     Find 1st Non-Numeric
         JZ    Find1600            B. If All Numerics

         CLI   0(R1),C'A'          Check For ALx
         JE    Find1500
         CLI   0(R1),C'B'          Check For BLx
         JE    Find1500
         CLI   0(R1),C'C'          Check For CLx
         JE    Find1400
         CLI   0(R1),C'D'          Check For DLx
         JE    Find1500
         CLI   0(R1),C'F'          Check For FLx
         JE    Find1500
         CLI   0(R1),C'H'          Check For HLx
         JE    Find1500
         CLI   0(R1),C'P'          Check For PLx
         JE    Find1500
         CLI   0(R1),C'X'          Check For XLx
         JE    Find1500

         OI    DSECTFL1,DSECT$AN   DTYPE=ANY
         J     Find1600

Find1400 DS    0H
         OI    DSECTFL1,DSECT$EB   DTYPE=EBCDIC
         J     Find1600

Find1500 DS    0H
         OI    DSECTFL1,DSECT$HX   DTYPE=HEX

Find1600 DS    0H
         MVC   NUMBER,DSECTOFF
         #ICALL CONVHEX            Convert Offset To Hex
         L     R5,WRKHEX           Load Current Entry's OFFSET
         ICM   R15,15,DSECTNXT     A(Next Entry)
         JZ    Find1900            B. If End Of DSECT
Find1700 DS    0H
         CLC   =C'CSECT ',DSECTOPC-DSECTMAP(R15)
         JE    Find1900            B. If End Of DSECT
         CLC   =C'DSECT ',DSECTOPC-DSECTMAP(R15)
         JE    Find1900            B. If End Of DSECT
         CLC   =C'RSECT ',DSECTOPC-DSECTMAP(R15)
         JE    Find1900            B. If End Of DSECT
         CLC   DSECTOFF-DSECTMAP(,R15),BLANKS
         JNE   Find1800            B. If Next Entry Offset Available
         ICM   R15,15,DSECTNXT-DSECTMAP(R15)
         JNZ   Find1700            B. If Next Entry Exists
         J     Find1900            Else. End Of DSECT
Find1800 DS    0H
         MVC   NUMBER,DSECTOFF-DSECTMAP(R15)
         #ICALL CONVHEX            Convert Offset To Hex
         L     R6,WRKHEX           Load Next Entry's OFFSET
         SR    R6,R5               Calculate Length Of 1st Entry
         CVD   R6,WRKDBL1
         OI    WRKDBL1+7,X'0F'
         UNPK  DSECTL,WRKDBL1      Save Length Of Field

         CLC   DSECTL,=C'00001'    Check If Length Is 1 Byte
         JNE   Find1300            B. If Not
         TM    DSECTFL1,DSECT$EB   Check For CL1 Byte
         JZ    Find1300            B. If Not
         ICM   R15,15,DSECTNXT
         JZ    Find1300            B. If No Following Entry
         CLC   =C'EQU ',DSECTOPC-DSECTMAP(R15)
         JNE   Find1300            B. If Not Followed By An EQU
         MVI   DSECTFL1,DSECT$HX   DTYPE=HEX
         J     Find1300

Find1900 DS    0H
         LHI   R15,0               Set Return Code
         J     FindExit

FindExit #IPEND ,

*---------------------------------------------------------------------*
*                                                                     *
*        Load Entire ASSEMBLY Output Into Storage                     *
*                                                                     *
*---------------------------------------------------------------------*
LoadASM  #IPROC ,

         LHI   R4,0                Initialize Statement Counter
Load0100 DS    0H
         GET   ASSEMBLY
         AHI   R4,1                Increment Statement Counter
         J     Load0100            B. Till End Of File

Load0200 DS    0H
         ST    R4,WRKASM#          Save Assembler Statement Count

         LH    R1,DCBLRECL-IHADCB+ASSEMBLY
         STH   R1,WRKASMEL         Save Assembler Output LRECL
         MH    R4,WRKASMEL         Calculate Required Buffer Length
         STORAGE OBTAIN,LENGTH=(R4),LOC=ANY,SP=1
         ST    R1,WRKASM@          Save Assembler Output Buffer Address
         ST    R4,WRKASML          Save Assembler Output Buffer Length

         CLOSE (ASSEMBLY)          Close The Assembler Output File
         LARL  R0,LoadExit         A(EODAD Address)
         ST    R0,DCBEEODA-DCBE+ASMDCBE
         OPEN  (ASSEMBLY,(INPUT))  Re-Open The Assembler Output File

         L     R5,WRKASM@          A(Assembler Output Buffer)
Load0300 DS    0H
         GET   ASSEMBLY            Get Assembler Output Record
         LH    R2,WRKASMEL         L(Assembler Output Record)
         #EXEC -R2,MVC,0(*-*,R5),0(R1)
         LA    R5,1(R2,R5)         A(End Of Current Assembler Record)
         J     Load0300            B. Till End Of File

LoadExit #IPEND ,

*---------------------------------------------------------------------*
*                                                                     *
*        Get Current Date                                             *
*                                                                     *
*---------------------------------------------------------------------*
GetDate  #IPROC ,

         MVC   WRKMAINT,=C'CCYY.DDD'
         L     R1,FLCCVT           A(CVT)
         USING CVT,R1
         L     R0,CVTDATE          Load 0CYYDDDF
         DROP  R1
         XC    WRKDBL1,WRKDBL1
         STCM  R0,8,WRKDBL1+3      Save Centuries Past 1900
         LHI   R15,19              Load Starting Point
         A     R15,WRKDBL1         Add Number Of Centuries Past 1900
         CVD   R15,WRKDBL1         Convert To Decimal
         OI    WRKDBL1+7,X'0F'
         UNPK  WRKMAINT(2),WRKDBL1+6(2)    Insert CC
         LR    R15,R0              Re-Load 0CYYDDDF
         STCM  R15,4,WRKMAINT+3    Save  Y
         SRL   R15,4
         STCM  R15,4,WRKMAINT+2    Save Y
         OC    WRKMAINT+2(2),=C'00'
         XC    WRKDBL1,WRKDBL1
         STH   R0,WRKDBL1+6        Save DDDF
         OI    WRKDBL1+7,X'0F'
         UNPK  WRKMAINT+5(3),WRKDBL1+6(2)  Insert DDD

         #IPEND ,

*---------------------------------------------------------------------*
*                                                                     *
*        Convert EBCDIC Hex Value To Hex                              *
*                                                                     *
*---------------------------------------------------------------------*
CONVHEX  #IPROC ,

         LAY   R15,HEXTAB2
         TR    NUMBER,0(R15)       Convert Character To Hex
         PACK  WRKDBL1,NUMBER(7)   Remove Top Nibbles
         MVC   WRKHEX,WRKDBL1+3    Save Converted Hex Value

         #IPEND ,                  Return To Caller

*---------------------------------------------------------------------*
*                                                                     *
*        Create an 8 byte LABEL= name from the current DSECT label.   *
*                                                                     *
*---------------------------------------------------------------------*
NAME8    #IPROC ,
         USING DSECTMAP,R4

         MVC   WNAME8,BLANKS       Clear Name Field
         MVI   WNAME8+8,C' '
         MVI   WNAME8,C'*'         Indicate "RSV" Area
         CLI   DSECTLAB,C'*'       Check If Field Has A Label
         JE    Name8Xit            B. If Not

         MVC   WrkTemp,BLANKS
         MVC   WrkTemp(L'DSECTLAB),DSECTLAB
         MVC   WNAME8,DSECTLAB     Copy To 8 Byte Name Field

*        Remove Matching PREFIX= Characters
         LA    R1,DSECTLAB         A(Start Of DSECT Label)
         GOIF  $PREFIX,OFF=Name8300
         LA    R2,WPREFIX          A(PREFIX= Value)
         SLR   R3,R3
         ICM   R3,1,WPREFIXL       L(PREFIX= Field)
Name8100 DS    0H
         CLI   0(R2),C' '          Check For End Of PREFIX=
         JE    Name8200            B. If Yes
         CLC   0(1,R2),0(R1)       Check For Matching Prefix Value
         JNE   Name8200            B. If Not (Done Stripping Prefix)
         LA    R1,1(,R1)           A(Next Byte In DSECT Label)
         LA    R2,1(,R2)           A(Next Byte In PREFIX= Value)
         BRCT  R3,Name8100         Loop Through PREFIX= Value
Name8200 DS    0H
         MVC   WrkTemp,BLANKS
         LA    R3,DSECTLAB+L'DSECTLAB
         SR    R3,R1               Calculate Suffix Length
         MVC   WrkTemp,BLANKS
         #EXEC -R3,MVC,WrkTemp(*-*),0(R1)
         MVC   WNAME8,WrkTemp      Copy To 8 Byte Name Field

*        Copy Last 8 Characters If "LAST8" Specified
Name8300 DS    0H
         GOIF  $LAST8,OFF=Name8Xit
         TRT   WrkTemp,BLANKTAB    Find End Of Label
         LA    R3,WrkTemp          A(Start Of Label)
         LR    R2,R1               A(End Of Label)
         SR    R2,R3               Calculate Length Of Label
         CHI   R2,8                Check For A Large Label
         JNH   Name8Xit            B. If NAME= Is Already Acceptable
         SHI   R1,8                Back Up To Last 8 Bytes Of Label
         MVC   WNAME8,0(R1)        Copy Last 8 Bytes

Name8Xit #IPEND ,                  Return To Caller

*---------------------------------------------------------------------*
*                                                                     *
*        Write record to SYSPUNCH (Called From UserExit)              *
*                                                                     *
*---------------------------------------------------------------------*
         PUSH  USING
PUNCH    DS    0H
         BAKR  R14,0               SAVE GPRs & ARs
         LARL  R12,$CNLS           Set Constants Base Register
         LAM   AR2,AR10,ZEROS      Clear The Access Registers
         LR    R5,R1               A(Punch Record)

         CLC   0(256,R5),BLANKS    Check If Punching a BLANK Line
         JNE   PUNC0100            B. If Not
         TM    WRKFLAG,W$BLANKS    Check If We Just Punched A BLANK
         JO    PUNCEXIT            B. If Yes (No Need For Another)
         OI    WRKFLAG,W$BLANKS    Remember We Punched A BLANK Line
         J     PUNC0200

PUNC0100 DS    0H
         NI    WRKFLAG,255-W$BLANKS Remember We Punched A Non-BLANK

PUNC0200 DS    0H
         PUT   SYSPUNCH,0(R5)      Punch The Current Record
         MVC   0(256,R5),BLANKS    Clear The Record Area

PUNCEXIT DS    0H                  Return To Caller
         PR    ,                   Restore GPR/AR 2-14 And Return
         POP   USING

*---------------------------------------------------------------------*
*                                                                     *
*        Write record to SYSTRACE (Called From UserExit)              *
*                                                                     *
*---------------------------------------------------------------------*
         PUSH  USING
PRINT    DS    0H
         BAKR  R14,0               SAVE GPRs & ARs
         LARL  R12,$CNLS           Set Constants Base Register
         LAM   AR2,AR10,ZEROS      Clear The Access Registers
         LR    R5,R1               A(Print Record)

         PUT   SYSTRACE,0(R5)
         MVC   0(256,R5),BLANKS

         PR    ,                   Restore GPR/AR 2-14 And Return
         POP   USING

*---------------------------------------------------------------------*
*                                                                     *
*        Write All The DSECTMAP Data                                  *
*                                                                     *
*---------------------------------------------------------------------*
DumpDsect #IPROC ,
         GOIF  $TRACE,OFF=DumpExit

         ICM   R4,15,WrkDSECT@     A(1st DSECTMAP Entry)
         JZ    DumpExit
         USING DSECTMAP,R4
         MVC   WRKTRACE,BLANKS
         MVC   WRKTRACE(L'Dumphdr1),Dumphdr1
         LA    R1,WRKTRACE
         #ICALL PRINT
         MVC   WRKTRACE(L'Dumphdr2),Dumphdr2
         LA    R1,WRKTRACE
         #ICALL PRINT
         LA    R1,WRKTRACE
         #ICALL PRINT

Dump0100 DS    0H
         UNPK  DMPNXT(9),DSECTNXT(5)
         LAY   R15,HEXTAB1
         TR    DMPNXT(8),0(R15)
         MVI   DMPNXT+8,C' '
         UNPK  DMPPRE(9),DSECTPRE(5)
         LAY   R15,HEXTAB1
         TR    DMPPRE(8),0(R15)
         MVI   DMPPRE+8,C' '
         MVC   DMPDSE,DSECT
         MVC   DMPPRL,DSECTPRL
         MVC   DMPPRO,DSECTPRO
         MVC   DMPLAB,DSECTLAB
         UNPK  DMPF1(3),DSECTFL1(2)
         LAY   R15,HEXTAB1
         TR    DMPF1(2),0(R15)
         MVI   DMPF1+2,C' '
         UNPK  DMPF2(3),DSECTFL2(2)
         LAY   R15,HEXTAB1
         TR    DMPF2(2),0(R15)
         MVI   DMPF2+2,C' '
         MVC   DMPOFF,DSECTOFF
         MVC   DMPVAL,DSECTVAL
         MVC   DMPL,DSECTL
         MVC   DMPOPC,DSECTOPC
         MVC   DMPOP,DSECTOP
         MVC   DMPCOM,DSECTCOM
         MVC   DMPDCL,DSECTDCL
         LA    R1,WRKTRACE
         #ICALL PRINT

         ICM   R4,15,DSECTNXT      A(Next DSECT Entry)
         JNZ   Dump0100
         #ICALL PRINT

DumpExit #IPEND ,                  Return To Caller

         #CON  RESUME
Dumphdr1 DC    C'NEXT     PREV     DSECT    PREV-LABEL           P-OFF *
                LABEL                F1 F2 OFF    VAL   LEN   OPCODE   *
               OPERAND  COMMENTS             DEC-LABEL'
Dumphdr2 DC    C'________ ________ ________ ____________________ ______*
                ____________________ __ __ ______ _____ _____ ________ *
               ________ ____________________ _________'
         #CON  REVERT

*---------------------------------------------------------------------*
*                                                                     *
*        Write record to SYSTRACE                                     *
*                                                                     *
*---------------------------------------------------------------------*
TRACE    #IPROC ,
         L     R4,WrkDSCUR@        A(Current DSECTMAP Entry)
         USING DSECTMAP,R4

         GOIF  $TRACE,OFF=TracExit
         TM    WRKFLAG,W$HEADER    Check If Already Written
         JO    TRACE100            B. If Yes
         OI    WRKFLAG,W$HEADER
         MVC   WRKTRACE,BLANKS
         MVC   WRKTRACE(L'TraceHd1),TraceHd1
         LA    R1,WRKTRACE
         #ICALL PRINT
         MVC   WRKTRACE(L'TraceHd2),TraceHd2
         LA    R1,WRKTRACE
         #ICALL PRINT
         LA    R1,WRKTRACE
         #ICALL PRINT

TRACE100 DS    0H
         TM    WRKFLAG,W$EXIT      Check If After USEREXIT
         JZ    TRACE300            B. If Not
         LA    R5,WRKUPARM         A(Exit Parameter List)
         USING EXITPARM,R5
         MVC   WRKTRACE(8),=C'D2BUSERX'
         MVC   WRKTRACE+9(3),=C'RS='
         UNPK  WRKTRACE+12(9),EXITRSCD(5)
         LAY   R15,HEXTAB1
         TR    WRKTRACE+12(8),0(R15)
         MVC   WRKTRACE+20(4),=C' RC='
         UNPK  WRKTRACE+24(9),EXITRSCD(5)
         LAY   R15,HEXTAB1
         TR    WRKTRACE+24(8),0(R15)
         MVI   WRKTRACE+32,C' '
         LTR   R4,R4               Check For DSECTMAP
         JZ    TRACE200            B. If Not Available
         MVC   WRKTRACE+33(9),=C'DSECTOFF='
         MVC   WRKTRACE+42(6),DSECTOFF
         MVC   WRKTRACE+49(9),=C'DSECTPRO='
         MVC   WRKTRACE+58(6),DSECTPRO
         MVC   WRKTRACE+65(9),=C'DSECTLAB='
         MVC   WRKTRACE+74(10),DSECTLAB
         MVC   WRKTRACE+85(9),=C'DSECTPRL='
         MVC   WRKTRACE+94(10),DSECTPRL
TRACE200 DS    0H
         DROP  R5
         LA    R1,WRKTRACE
         #ICALL PRINT

TRACE300 DS    0H
         LTR   R4,R4               Check For DSECTMAP
         JZ    TracExit            B. If Not Available
         MVC   WTDSECT,DSECT
         MVC   WTDSOFF,DSECTOFF
         MVC   WTDSVAL,DSECTVAL
         MVC   WTDSL,DSECTL
         MVC   WTDSOPC,DSECTOPC
         MVC   WTDSOP,DSECTOP
         MVC   WTDSDCL,DSECTDCL
         UNPK  WTDSF1(3),DSECTFL1(2)
         LAY   R15,HEXTAB1
         TR    WTDSF1(2),0(R15)
         MVI   WTDSF1+2,C' '
         UNPK  WTDSF2(3),DSECTFL2(2)
         LAY   R15,HEXTAB1
         TR    WTDSF2(2),0(R15)
         MVI   WTDSF2+2,C' '
         MVC   WTDSLAB,DSECTLAB
         MVC   WTDSCOM,DSECTCOM
         LA    R1,WRKTRACE
         #ICALL PRINT

TracExit #IPEND ,                  Return To Caller

         #CON  RESUME
TraceHd1 DC    C'DSECT    DSECTOFF DSECTVAL DSECTL DSECTOPC DSECTOP  DS*
               ECTDCL DSECTFL1 DSECTFL2 DSECTLAB'
TraceHd2 DC    C'_____    ________ ________ ______ ________ _______  __*
               ______ ________ ________ ________'
         #CON  REVERT

*---------------------------------------------------------------------*
*                                                                     *
*        Call Installation Processing Routine                         *
*                                                                     *
*---------------------------------------------------------------------*
USEREXIT #IPROC ,
         ST    R1,WrkDSCUR@        A(Current DSECTMAP)
         LA    R5,WRKUPARM         A(Exit Parameter List)
         USING EXITPARM,R5
         LTR   R6,R1               A(DSECTMAP)
         JZ    USEREX30            B. If Not Provided
         USING DSECTMAP,R6
         MVC   DSECTPRL,BLANKS     Clear Previous DSECTLAB
         MVC   DSECTPRO,BLANKS     Clear Previous DSECTOFF

         ICM   R2,15,DSECTPRE      A(Previous DSECTMAP Entry)
         JZ    USEREX30            B. If At The Beginning
PREV     USING DSECTMAP,R2
USEREX10 DS    0H
         TM    PREV.DSECTOFF,X'F0' Check For Previous Offset
         JNO   USEREX20            B. If Not
         MVC   DSECTPRO,PREV.DSECTOFF Set Previous Offset
         MVC   DSECTPRL,PREV.DSECTLAB Set Previous Label
         J     USEREX30
USEREX20 DS    0H
         ICM   R2,15,PREV.DSECTPRE A(Previous DSECTMAP Entry)
         JNZ   USEREX10            B. If At The Beginning
         DROP  PREV

USEREX30 DS    0H
         XC    EXITRSCD,EXITRSCD   Clear Reason Code
         XC    EXITRECD,EXITRECD   Clear Return Code

         WXTRN D2BUSERX
         ICM   R15,15,=V(D2BUSERX) A(Installation Exit Routine)
         JZ    USEREX99            B. If No Exit Provided

         MVC   EXITNAME,WRKNAME    Current Macro Name
         ST    R0,EXITNUM          Save Exit Number
         ST    R6,EXITIREC         A(Current DSECTMAP Record)
         L     R0,=A(PRINT)        A(Print Output Routine)
         ST    R0,EXITTRA@
         LA    R0,WRKTRACE         A(Print Output Record)
         ST    R0,EXITTRAR
         L     R0,=A(PUNCH)        A(Punch Output Routine)
         ST    R0,EXITPUN@
         LA    R0,WRKPUNCH         A(Punch Output Record)
         ST    R0,EXITPUNR

         L     R0,EXITNUM          #(Exit Invocation)
         LR    R1,R5               A(Exit Parameter List)
         BASR  R14,R15             Invoke Installation Exit

         OI    WRKFLAG,W$EXIT      Indicate After USEREXIT
         #ICALL TRACE
         NI    WRKFLAG,255-W$EXIT

         L     R0,EXITRSCD         Load Reason Code
         L     R15,EXITRECD        Load Return Code

         LTR   R15,R15             Check Return Code
         JZ    USEREX99            B. If Zero
         LHI   R15,8               Set Return Code To 8

USEREX99 #IPEND ,

*---------------------------------------------------------------------*
*                                                                     *
*        CONSTANTS AND WORK AREA                                      *
*                                                                     *
*---------------------------------------------------------------------*

         #CON  START
         LTORG ,                   Literal Pool
         #EXEC ,                   Executed Statements

@SHEADER DC    C'BLSQMFLD SHDR=$_______,NEWLINE'

ErrMsg01  DC   AL2(29),C'D2BLS01I Missing DSECT= label'
ErrMsg01L EQU  *-ErrMsg01
ErrMsg02  DC   AL2(38),C'D2BLS02I Invalid PARM= Value: ________'
ErrMsg02L EQU  *-ErrMsg02
ErrMsg02A EQU  2+30,8              Insert Offset/Length
ErrMsg03  DC   AL2(46),C'D2BLS03I Duplicate Keyword: ________'
ErrMsg03L EQU  *-ErrMsg03
ErrMsg03A EQU  2+28,8              Insert Offset/Length
ErrMsg04  DC   AL2(34),C'D2BLS04I Missing Operand: ________'
ErrMsg04L EQU  *-ErrMsg04
ErrMsg04A EQU  2+26,8              Insert Offset/Length
ErrMsg05  DC   AL2(34),C'D2BLS05I Invalid Operand: ________'
ErrMsg05L EQU  *-ErrMsg05
ErrMsg05A EQU  2+26,8              Insert Offset/Length
ErrMsg06  DC   AL2(37),C'D2BLS06I ACRONYM=, LABEL= or PREFIX= Required'
ErrMsg06L EQU  *-ErrMsg06
ErrMsg07  DC   AL2(37),C'D2BLS07I SYSIN Contains No Data'
ErrMsg07L EQU  *-ErrMsg07
ErrMsg08  DC   AL2(27),C'D2BLS08I Missing PTF= label'
ErrMsg08L EQU  *-ErrMsg08

ASSEMBLY DCB   DDNAME=ASSEMBLY,DSORG=PS,MACRF=GL,DCBE=ASMDCBE
ASMDCBE  DCBE  EODAD=Load0200
SYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,                      X
               RECFM=FB,EXLST=OPENLST
SYSPUNCH DCB   DDNAME=SYSPUNCH,DSORG=PS,MACRF=PM,                      X
               RECFM=FB,EXLST=OPENLST
SYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=GL,LRECL=80,DCBE=SYSINE,    X
               RECFM=FB,EXLST=OPENLST
SYSINE   DCBE  EODAD=Chec0500

OPENLST  DC    X'85',AL3(DCBEXIT)
DCBEXIT  #DCBEXIT LRECL=80

CZEROS   DC    72C'0'              Lots Of Zeros
BLANKS   DC    256C' '             Lots Of Blanks
ZEROS    DC    16F'0'              Lots Of Zeros

BLANKTAB DC    256X'00'            Find Blanks
         ORG   BLANKTAB+C' '
         DC    C' '
         ORG   ,

NBLANKTAB DC    256X'FF'           Find Non-Blanks
         ORG   NBLANKTAB+C' '
         DC    X'00'
         ORG   ,

NUMBERS  DC    256X'FF'            Find Numerics (or Blanks)
         ORG   NUMBERS+C' '
         DC    X'00'               Blanks
         ORG   NUMBERS+C'0'
         DC    10X'00'             0123456789
         ORG   ,

NONNUMS  DC    256X'FF'            Find Non-Numerics
         ORG   NONNUMS+C'0'
         DC    10X'00'             0123456789
         ORG   ,

TRTABLE1 DC    256X'00'
         ORG   TRTABLE1+C' '       Find Blanks
         DC    C' '
         ORG   TRTABLE1+C','       Or Commas
         DC    C','
         ORG   ,

TRTABLE2 DC    256AL1(*-TRTABLE2)  All-Characters Defined
         ORG   TRTABLE2+X'50'
         DC    C'+'                Convert And To Plus
         ORG   TRTABLE2+C''''
         DC    C'"'                Convert Quote To Double-Quote
         ORG   ,

TRTABLE3 DC    256X'00'
         ORG   TRTABLE3+C''''      Find Trailing Quote
         DC    C''''
         ORG   ,

HEXTAB1  DC    256X'00'
         ORG   HEXTAB1+C'0'
         DC    C'0123456789ABCDEF'
         ORG   ,

HEXTAB2  DC    256X'00'
         ORG   HEXTAB2+C'0'
         DC    X'00010203040506070809'
         ORG   HEXTAB2+C'A'
         DC    X'0A0B0C0D0E0F'
         ORG   ,

         #CON  END,PATCH=NO

         #STARTWA PATCH=NO
         DCLSW MF=L                Define Switches
         #IPROC MODE=DEFINE
WRKPARM@ DS    A                   A(Input Parameters)
WRKPARMT DS    A                   A(Input Parameter Text)
WRKPARMS DS    A                   A(Simulated PARM=)
WRKPARML DS    F                   L(Input Parameters)
WRKPARM  DS    CL256               Input Parameter String
WRKPTFID DS    CL8                 PTF=
WRKNAME  DS    CL8                 NAME=    (Default=________)
WRKMAINT DS    CL8'CCYY.DDD'       MAINTLV= (Default=Julian Date)
WRKCBLEN DS    CL6                 CBLEN=   (Default defined by DSECT)
WRKOFFS  DS    CL7                 OFFSETS=PRINT/NOPRINT
WRKASM#  DS    F                   Assembler Statement Count
WRKASM@  DS    A                   Assembler Output Address
WRKASML  DS    F                   Assembler Output Length
WRKASMEL DS    H                   Assembler Output Entry Length

WRKPREV@ DS    A                   A(Previous DSECT Entry)

ParseSA  DS    16F                 Parse SubRoutine Save Area

WrkTemp  DS    CL256               Temporary Area

WrkDSECTL DS   AL1                 L(DSECT Label)
WrkDSECT DS    CL65                DSECT Label
WrkDSECT@ DS   A                   A(DSECT Information - DSECTMAP)
WrkDSCUR@ DS   A                   A(Current DSECTMAP Entry)
WrkDSELen DS   CL5                 Defined DSECT Length
WrkEQUL  DS    CL8                 EQU Flag Label
WrkEQU@  DS    A                   A(1st EQU Label)

WRKDBL1  DS    D                   Conversion Work Area
WRKDBL2  DS    D                   Conversion Work Area

NUMBER   DS    CL6                 Input EBCDIC HEX Number
WRKHEX   DS    F                   Converted Hex Value

WrkLabelL DS   AL1                 Length Of Macro Name
WrkLabel DS    CL65                Macro Name (Plus Trailing Blank)

WRKFLAG  DS    XL1                 Flag Byte
W$DECODE EQU   B'10000000'         - DECODE Statement Added
W$NEWLINE EQU  B'01000000'         - NEWLINE Needed for next FLD
W$BLANKS  EQU  B'00100000'         - Previous PUNCH record was BLANKS
W$HEADER EQU   B'00010000'         - Trace Header Written
W$EXIT   EQU   B'00001000'         - Trace After USEREXIT
W$LABEL  EQU   B'00000100'         - Label Line Written
WrkStOff DS    F                   Decode Starting Offset

WRKCHAIN DS    A                   DSECT Chain Beginning
WRKLAST  DS    A                   Last DSECT Entry Address

WRKFULL1 DS    F
WRKFULL2 DS    F

LABEL    DS    CL80                Current Statement's Label
OPCODE   DS    CL80                Current Statement's Opcode
OPERAND  DS    CL80                Current Statement's Operand

LENGTH   DS    CL6                 Current DSECT Length
OFFSET   DS    CL6                 Current Statement DSECT Offset

         DS    0F
WRKPUNCH DS    CL256               Output Record Buffer
         DS    0F
WRKTRACE DS    CL256               Output Record Buffer

         ORG   WRKTRACE            Record Trace Data
WTDSECT  DS    CL8
         DS    CL1
WTDSOFF  DS    CL6
         DS    CL3
WTDSVAL  DS    CL5
         DS    CL4
WTDSL    DS    CL5
         DS    CL2
WTDSOPC  DS    CL8
         DS    CL1
WTDSOP   DS    CL8
         DS    CL1
WTDSDCL  DS    CL8
         DS    CL1
WTDSF1   DS    CL2
         DS    CL7
WTDSF2   DS    CL2
         DS    CL7
WTDSLAB  DS    CL64
         DS    CL1
WTDSCOM  DS    CL65
         ORG   ,

         ORG   WRKTRACE            DSECT Dump Data
DMPNXT   DS    CL8                 Next DSECTMAP Address
         DS    CL1
DMPPRE   DS    CL8                 Previous DSECTMAP Address
         DS    CL1
DMPDSE   DS    CL8                 DSECT Name
         DS    CL1
DMPPRL   DS    CL20                Previous Label
         DS    CL1
DMPPRO   DS    CL6                 Previous Offset
         DS    CL1
DMPLAB   DS    CL20                Current Label
         DS    CL1
DMPF1    DS    CL2                 Flag 1
         DS    CL1
DMPF2    DS    CL2                 Flag 2
         DS    CL1
DMPOFF   DS    CL6                 Offset
         DS    CL1
DMPVAL   DS    CL5                 Value
         DS    CL1
DMPL     DS    CL5                 Length
         DS    CL1
DMPOPC   DS    CL8                 Opcode
         DS    CL1
DMPOP    DS    CL8                 Operand
         DS    CL1
DMPCOM   DS    CL20                Comments
         DS    CL1
DMPDCL   DS    CL8                 DECODE Label
         ORG   ,

WACROFF  DS    CL6                 ACROFF=   (Determined from DSECT)
WACROLEN DS    CL5                 ACROLEN=  (Determined from DSECT)
WACRONYM DS    CL8                 ACRONYM=  (Specified In PARM)
WACROLBL DS    CL64                ACROLBL=  (Specified In PARM)
WHEADER  DS    CL8                 HEADER=   (Specified In PARM)
WPREFIXL DS    AL1                 PREFIX= Length
WPREFIX  DS    CL8                 PREFIX=   (Specified In PARM)
WSUBHDR  DS    CL3                 Subheader
WDECODE# DS    F                   DECODE Statement Counter
WSUBHDR# DS    F                   SHDR   Statement Counter
WPRINT   DS    CL8                 GEN/NOGEN Print Option
WNAME8   DS    CL8,C               NAME=
WSHEADER DS    CL50                Heading Text
WSFOOTER DS    CL50                Footing Text
WSTART   DS    CL64                START= Label

WRKUPARM DS    0F,XL(EXITPLEN)     Exit Routine Parameter List
         #STOPWA ,

*---------------------------------------------------------------------*
*                                                                     *
*        DSECTS                                                       *
*                                                                     *
*---------------------------------------------------------------------*

ASMLIST  DSECT ,
ASMCC    DS    C                   ASA/Machine Control Character
ASMLOC   DS    CL6                 Location
         DS    CL16
ASMADDR1 DS    CL5                 Value
         DS    CL1
ASMADDR2 DS    CL5                 Length
         DS    CL1
ASMSTMT  DS    CL5                 Statement Number
ASMPLUS  DS    CL1                 "+" For Macro Statement
ASMLINE  DS    CL72                Expanded Text Line
ASMCONT  DS    CL1                 Non-Blank For Continuation

DSECTMAP DSECT ,
DSECTNXT DS    A                   A(Next Entry In Chain)
DSECTPRE DS    A                   A(Previous Entry In Chain)
DSECT    DS    CL8                 Name
DSECTPRL DS    CL64                Previous Label
DSECTPRO DS    CL6                 Previous Offset
DSECTLAB DS    CL64                Label
DSECTFL1 DS    X                   Flag Byte
DSECT$HX EQU   B'10000000'         DTYPE=HEX
DSECT$EB EQU   B'01000000'         DTYPE=EBCDIC
DSECT$AN EQU   B'00100000'         DTYPE=ANY
DSECT$AQ EQU   B'00100000'         DTYPE=QANY  (Not Used)
DSECT$AS EQU   B'00100000'         DTYPE=ASCII (Not Used)
DSECT$DE EQU   B'00010000'         DECODE This Byte
DSECTFL2 DS    X                   Flab Byte #2
DSECT$AE EQU   B'10000000'         - Add "ARRAY=END"
DSECT$DC EQU   B'01000000'         - Add "DECODE"
DSECT$NL EQU   B'00100000'         - Add "NEWLINE"
DSECT$ST EQU   B'00010000'         - Add "STACK"
DSECT$XL EQU   B'00001000'         - Add "NOLABEL"
DSECT$VM EQU   B'00000100'         - Add "VIEWMATCH=VALUE"
DSECTOFF DS    CL6                 Offset
DSECTVAL DS    CL5                 Value
DSECTL   DS    CL5                 Length
DSECTOPC DS    CL8                 Opcode
DSECTOP  DS    CL8                 Operand
DSECTCOM DS    CL65                Comments
DSECTDCL DS    CL8                 DECODE Label
DSECTLEN EQU   *-DSECTMAP

EXITPARM DSECT ,
EXITNAME DS    CL8                 Macro Name
EXITNUM  DS    F                   Exit Call Number
EXITIREC DS    A                   A(Current DSECT Record ("DSECTMAP"))
EXITTRA@ DS    A                   A(SYSTRACE Routine ("PRINT"))
EXITTRAR DS    A                   A(SYSTRACE Record  ("WRKTRACE"))
EXITPUN@ DS    A                   A(SYSPUNCH Routine ("PUNCH"))
EXITPUNR DS    A                   A(SYSPUNCH Record  ("WRKOUT"))
EXITRSCD DS    F                   Exit Reason Code (R0)
EXITRECD DS    F                   Exit Return Code (R15)
EXITPLEN EQU   *-EXITPARM

         #DSECTS CVT,DCB,DCBE,PSA
         END   ,
